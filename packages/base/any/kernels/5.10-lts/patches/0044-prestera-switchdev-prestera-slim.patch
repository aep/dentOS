diff --git a/drivers/net/ethernet/marvell/prestera/Makefile b/drivers/net/ethernet/marvell/prestera/Makefile
index 28a9e5d..2c2881e 100644
--- a/drivers/net/ethernet/marvell/prestera/Makefile
+++ b/drivers/net/ethernet/marvell/prestera/Makefile
@@ -3,15 +3,16 @@
 # Makefile for the Marvell Switch driver.
 #
 
-obj-$(CONFIG_PRESTERA) += prestera.o
+obj-$(CONFIG_PRESTERA) += prestera.o
 prestera-objs := prestera_main.o \
 	prestera_hw.o prestera_switchdev.o prestera_devlink.o prestera_fw_log.o \
 	prestera_rxtx.o prestera_dsa.o prestera_router.o \
 	prestera_acl.o prestera_flow.o prestera_flower.o prestera_matchall.o prestera_debugfs.o \
 	prestera_ct.o prestera_ethtool.o prestera_counter.o \
-	prestera_router_hw.o
+	prestera_fw.o prestera_router_hw.o prestera_dcb.o
 
-prestera-$(CONFIG_PRESTERA_DEBUG) += prestera_log.o
-ccflags-$(CONFIG_PRESTERA_DEBUG) += -DCONFIG_MRVL_PRESTERA_DEBUG
+prestera-$(CONFIG_PRESTERA_DEBUG) += prestera_log.o
+ccflags-$(CONFIG_PRESTERA_DEBUG) += -DCONFIG_MRVL_PRESTERA_DEBUG
 
-obj-$(CONFIG_PRESTERA_PCI) += prestera_pci.o
+obj-$(CONFIG_PRESTERA_SHM) += prestera_shm.o
+obj-$(CONFIG_PRESTERA_PCI) += prestera_pci.o
diff --git a/drivers/net/ethernet/marvell/prestera/prestera.h b/drivers/net/ethernet/marvell/prestera/prestera.h
index 08cf4a4..9669c43 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera.h
@@ -30,6 +30,7 @@
 #define PRESTERA_PORT_SRCID_ZERO 0 /* source_id */
 
 #define PRESTERA_SPAN_INVALID_ID -1
+#define PRESTERA_QOS_SP_COUNT 8
 
 struct prestera_fw_rev {
 	u16 maj;
@@ -46,6 +47,7 @@ struct prestera_acl_nat_port;
 struct prestera_span;
 struct prestera_span_entry;
 struct prestera_storm_control;
+struct prestera_qos;
 
 struct prestera_flow_block_binding {
 	struct list_head list;
@@ -74,6 +76,26 @@ struct prestera_port_vlan {
 	struct list_head bridge_vlan_node;
 };
 
+struct prestera_flood_domain {
+	struct prestera_switch *sw;
+	struct list_head flood_domain_port_list;
+	u32 idx;
+};
+
+struct prestera_mdb_entry {
+	unsigned char addr[ETH_ALEN];
+	struct prestera_switch *sw;
+	struct prestera_flood_domain *flood_domain;
+	u16 vid;
+};
+
+struct prestera_flood_domain_port {
+	struct prestera_flood_domain *flood_domain;
+	struct net_device *dev;
+	struct list_head flood_domain_port_node;
+	u16 vid;
+};
+
 struct prestera_port_stats {
 	u64 good_octets_received;
 	u64 bad_octets_received;
@@ -115,6 +137,7 @@ struct prestera_port_caps {
 };
 
 struct prestera_port_mac_state {
+	bool valid;
 	bool oper;
 	u32 mode;
 	u32 speed;
@@ -181,11 +204,14 @@ struct prestera_port {
 		struct delayed_work caching_dw;
 	} cached_hw_stats;
 	struct prestera_flow_block *flow_block;
+	struct prestera_qos *qos;
 
 	struct phylink_config phy_config;
 	struct phylink *phy_link;
 
+	rwlock_t state_mac_lock;
 	struct prestera_port_mac_state state_mac;
+	/* TODO: phy lock */
 	struct prestera_port_phy_state state_phy;
 
 	struct prestera_rxtx_stats __percpu *rxtx_stats;
@@ -197,6 +223,7 @@ struct prestera_device {
 	struct workqueue_struct *dev_wq;
 	u8 __iomem *pp_regs;
 	void *priv;
+	gfp_t dma_flags;
 
 	struct delayed_work keepalive_wdog_work;
 	atomic_t keepalive_wdog_counter;
@@ -436,6 +463,7 @@ enum prestera_acl_match_type {
 	PRESTERA_ACL_RULE_MATCH_TYPE_VLAN_TPID,
 	PRESTERA_ACL_RULE_MATCH_TYPE_ICMP_TYPE,
 	PRESTERA_ACL_RULE_MATCH_TYPE_ICMP_CODE,
+	PRESTERA_ACL_RULE_MATCH_TYPE_QOS_PROFILE,
 
 	__PRESTERA_ACL_RULE_MATCH_TYPE_MAX
 };
@@ -453,7 +481,8 @@ enum prestera_acl_rule_action {
 	PRESTERA_ACL_RULE_ACTION_NAT,
 	PRESTERA_ACL_RULE_ACTION_JUMP,
 	PRESTERA_ACL_RULE_ACTION_NH,
-	PRESTERA_ACL_RULE_ACTION_COUNT
+	PRESTERA_ACL_RULE_ACTION_COUNT,
+	PRESTERA_ACL_RULE_ACTION_REMARK
 };
 
 struct prestera_acl_action_jump {
@@ -481,6 +510,10 @@ struct prestera_acl_action_count {
 	u32 id;
 };
 
+struct prestera_acl_action_remark {
+	u32 dscp;
+};
+
 /* Used for hw call */
 struct prestera_acl_hw_action_info {
 	enum prestera_acl_rule_action id;
@@ -491,6 +524,7 @@ struct prestera_acl_hw_action_info {
 		struct prestera_acl_action_nat nat;
 		struct prestera_acl_action_jump jump;
 		struct prestera_acl_action_count count;
+		struct prestera_acl_action_remark remark;
 	};
 };
 
@@ -621,6 +655,26 @@ prestera_port_vlan_find_by_vid(const struct prestera_port *port, u16 vid);
 void
 prestera_port_vlan_bridge_leave(struct prestera_port_vlan *mvsw_pr_port_vlan);
 
+/* MDB / flood domain API*/
+struct prestera_mdb_entry *
+prestera_mdb_entry_create(struct prestera_switch *sw,
+			  const unsigned char *addr, u16 vid);
+void prestera_mdb_entry_destroy(struct prestera_mdb_entry *mdb_entry);
+
+struct prestera_flood_domain *
+prestera_flood_domain_create(struct prestera_switch *sw);
+void prestera_flood_domain_destroy(struct prestera_flood_domain *flood_domain);
+
+int
+prestera_flood_domain_port_create(struct prestera_flood_domain *flood_domain,
+				  struct net_device *dev,
+				  u16 vid);
+struct prestera_flood_domain_port *
+prestera_flood_domain_port_find(struct prestera_flood_domain *flood_domain,
+				struct net_device *dev, u16 vid);
+void
+prestera_flood_domain_port_destroy(struct prestera_flood_domain_port *port);
+
 int prestera_switchdev_register(struct prestera_switch *sw);
 void prestera_switchdev_unregister(struct prestera_switch *sw);
 
@@ -633,6 +687,10 @@ int prestera_port_cfg_mac_read(struct prestera_port *port,
 			       struct prestera_port_mac_config *cfg);
 int prestera_port_cfg_mac_write(struct prestera_port *port,
 				struct prestera_port_mac_config *cfg);
+void prestera_port_mac_state_cache_read(struct prestera_port *port,
+					struct prestera_port_mac_state *state);
+void prestera_port_mac_state_cache_write(struct prestera_port *port,
+					 struct prestera_port_mac_state *state);
 struct prestera_port *prestera_port_dev_lower_find(struct net_device *dev);
 
 struct prestera_port *prestera_port_find(u32 dev_hw_id, u32 port_hw_id);
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_acl.c b/drivers/net/ethernet/marvell/prestera/prestera_acl.c
index b7768d2..b76fa1b 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_acl.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_acl.c
@@ -44,6 +44,7 @@ struct prestera_acl_vtcam {
 	__be32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
 	bool is_keymask_set;
 	refcount_t refcount;
+	u8 direction;
 	u8 lookup;
 	u32 id;
 };
@@ -76,18 +77,19 @@ static const struct rhashtable_params __prestera_acl_rule_entry_ht_params = {
 	.automatic_shrinking = true,
 };
 
-enum prestera_counter_client prestera_acl_chain_to_client(u32 chain_index)
+int prestera_acl_chain_to_client(u32 chain_index, u32 *client)
 {
-	enum prestera_counter_client client[] = {
-		PRESTERA_COUNTER_CLIENT_LOOKUP_0,
-		PRESTERA_COUNTER_CLIENT_LOOKUP_1,
-		PRESTERA_COUNTER_CLIENT_LOOKUP_2
+	u32 client_map[] = {
+		PRESTERA_HW_COUNTER_CLIENT_LOOKUP_0,
+		PRESTERA_HW_COUNTER_CLIENT_LOOKUP_1,
+		PRESTERA_HW_COUNTER_CLIENT_LOOKUP_2
 	};
 
-	if (chain_index > 2)
-		return PRESTERA_COUNTER_CLIENT_LOOKUP_LAST;
+	if (chain_index > ARRAY_SIZE(client_map))
+		return -EINVAL;
 
-	return client[chain_index];
+	*client = client_map[chain_index];
+	return 0;
 }
 
 struct prestera_acl_nat_port *
@@ -153,7 +155,7 @@ prestera_acl_ruleset_create(struct prestera_acl *acl,
 {
 	struct prestera_acl_ruleset *ruleset;
 	int err;
-	u8 uid;
+	u32 uid = 0;
 
 	if (!prestera_acl_chain_is_supported(chain_index))
 		return ERR_PTR(-EINVAL);
@@ -171,12 +173,12 @@ prestera_acl_ruleset_create(struct prestera_acl *acl,
 	if (err)
 		goto err_rhashtable_init;
 
-	err = prestera_acl_uid_new_get(acl, &uid);
+	err = idr_alloc_u32(&acl->uid, NULL, &uid, U8_MAX, GFP_KERNEL);
 	if (err)
 		goto err_ruleset_create;
 
 	/* make pcl-id based on uid and chain */
-	ruleset->pcl_id = PRESTERA_ACL_PCL_ID_MAKE(uid, chain_index);
+	ruleset->pcl_id = PRESTERA_ACL_PCL_ID_MAKE((u8)uid, chain_index);
 	ruleset->index = uid;
 
 	err = rhashtable_insert_fast(&acl->ruleset_ht, &ruleset->ht_node,
@@ -187,7 +189,7 @@ prestera_acl_ruleset_create(struct prestera_acl *acl,
 	return ruleset;
 
 err_ruleset_ht_insert:
-	prestera_acl_uid_release(acl, uid);
+	idr_remove(&acl->uid, uid);
 err_ruleset_create:
 	rhashtable_destroy(&ruleset->rule_ht);
 err_rhashtable_init:
@@ -224,6 +226,7 @@ int prestera_acl_ruleset_offload(struct prestera_acl_ruleset *ruleset)
 
 	err = prestera_acl_vtcam_id_get(ruleset->acl,
 					ruleset->ht_key.chain_index,
+					PRESTERA_HW_VTCAM_DIR_INGRESS,
 					ruleset->keymask, &vtcam_id);
 	if (err)
 		goto err_vtcam_create;
@@ -272,8 +275,7 @@ static void prestera_acl_ruleset_destroy(struct prestera_acl_ruleset *ruleset)
 		WARN_ON(prestera_acl_vtcam_id_put(acl, ruleset->vtcam_id));
 	}
 
-	WARN_ON(prestera_acl_uid_release(acl, uid));
-
+	idr_remove(&acl->uid, uid);
 	rhashtable_destroy(&ruleset->rule_ht);
 	kfree(ruleset->keymask);
 	kfree(ruleset);
@@ -582,12 +584,10 @@ int prestera_acl_rule_add(struct prestera_switch *sw,
 
 	/* setup counter */
 	rule->re_arg.count.valid = true;
-	rule->re_arg.count.client =
-		prestera_acl_chain_to_client(ruleset->ht_key.chain_index);
-	if (rule->re_arg.count.client == PRESTERA_COUNTER_CLIENT_LOOKUP_LAST) {
-		err = -EINVAL;
+	err = prestera_acl_chain_to_client(ruleset->ht_key.chain_index,
+					   &rule->re_arg.count.client);
+	if (err)
 		goto err_rule_add;
-	}
 
 	if (rule_flag_test(rule, CT)) {
 		err = prestera_ct_ft_offload_add_cb(sw, rule);
@@ -852,11 +852,8 @@ struct prestera_acl_rule_entry *
 prestera_acl_rule_entry_find(struct prestera_acl *acl,
 			     struct prestera_acl_rule_entry_key *key)
 {
-	struct prestera_acl_rule_entry *e;
-
-	e = rhashtable_lookup_fast(&acl->acl_rule_entry_ht, key,
-				   __prestera_acl_rule_entry_ht_params);
-	return IS_ERR(e) ? NULL : e;
+	return rhashtable_lookup_fast(&acl->acl_rule_entry_ht, key,
+				      __prestera_acl_rule_entry_ht_params);
 }
 
 static int __prestera_acl_rule_entry2hw_del(struct prestera_switch *sw,
@@ -920,6 +917,12 @@ static int __prestera_acl_rule_entry2hw_add(struct prestera_switch *sw,
 		act_hw[act_num].count.id = e->counter.id;
 		act_num++;
 	}
+	/* egress remark */
+	if (e->remark.valid) {
+		act_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_REMARK;
+		act_hw[act_num].remark = e->remark.i;
+		act_num++;
+	}
 
 	return prestera_hw_vtcam_rule_add(sw, e->vtcam_id, e->key.prio,
 					  e->key.match.key, e->key.match.mask,
@@ -994,6 +997,9 @@ __prestera_acl_rule_entry_act_construct(struct prestera_switch *sw,
 		if (err && arg->count.fail_on_err)
 			goto err_out;
 	}
+	/* remark */
+	e->remark.valid = arg->remark.valid;
+	e->remark.i = arg->remark.i;
 
 	return 0;
 
@@ -1044,56 +1050,6 @@ prestera_acl_rule_entry_create(struct prestera_acl *acl,
 	return NULL;
 }
 
-int prestera_acl_uid_new_get(struct prestera_acl *acl, u8 *uid)
-{
-	struct prestera_acl_uid_entry *uid_entry;
-
-	uid_entry = list_first_entry_or_null(&acl->uid.free_list,
-					     typeof(*uid_entry), list);
-	if (uid_entry) {
-		list_del(&uid_entry->list);
-		*uid = uid_entry->id;
-		kfree(uid_entry);
-		return 0;
-	}
-
-	if (!(acl->uid.next + 1))
-		/* max number reached */
-		return -ENOENT;
-
-	*uid = acl->uid.next++;
-	return 0;
-}
-
-int prestera_acl_uid_release(struct prestera_acl *acl, u8 id)
-{
-	struct prestera_acl_uid_entry *uid_entry;
-
-	if (!(id < acl->uid.next))
-		return -EINVAL;
-
-	uid_entry = kmalloc(sizeof(*uid_entry), GFP_KERNEL);
-	if (!uid_entry)
-		return -ENOMEM;
-
-	uid_entry->id = id;
-	list_add_rcu(&uid_entry->list, &acl->uid.free_list);
-
-	return 0;
-}
-
-static void prestera_acl_uid_destroy(struct prestera_acl *acl)
-{
-	struct prestera_acl_uid_entry *uid_entry;
-	struct list_head *pos, *n;
-
-	list_for_each_safe(pos, n, &acl->uid.free_list) {
-		uid_entry = list_entry(pos, typeof(*uid_entry), list);
-		list_del(&uid_entry->list);
-		kfree(uid_entry);
-	}
-}
-
 static int __prestera_acl_vtcam_id_try_fit(struct prestera_acl *acl, u8 lookup,
 					   void *keymask, u32 *vtcam_id)
 {
@@ -1137,7 +1093,7 @@ static int __prestera_acl_vtcam_id_try_fit(struct prestera_acl *acl, u8 lookup,
 	return 0;
 }
 
-int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup,
+int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup, u8 dir,
 			      void *keymask, u32 *vtcam_id)
 {
 	struct prestera_acl_vtcam *vtcam;
@@ -1149,7 +1105,8 @@ int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup,
 	 * fine for now
 	 */
 	list_for_each_entry(vtcam, &acl->vtcam_list, list) {
-		if (lookup != vtcam->lookup)
+		if (lookup != vtcam->lookup ||
+		    dir != vtcam->direction)
 			continue;
 
 		if (!keymask && !vtcam->is_keymask_set) {
@@ -1170,7 +1127,7 @@ int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup,
 		return -ENOMEM;
 
 	err = prestera_hw_vtcam_create(acl->sw, lookup, keymask, &new_vtcam_id,
-				       PRESTERA_HW_VTCAM_DIR_INGRESS);
+				       dir);
 	if (err) {
 		kfree(vtcam);
 
@@ -1183,6 +1140,7 @@ int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup,
 		return 0;
 	}
 
+	vtcam->direction = dir;
 	vtcam->id = new_vtcam_id;
 	vtcam->lookup = lookup;
 	if (keymask) {
@@ -1236,7 +1194,7 @@ int prestera_acl_init(struct prestera_switch *sw)
 	INIT_LIST_HEAD(&acl->rules);
 	INIT_LIST_HEAD(&acl->nat_port_list);
 	INIT_LIST_HEAD(&acl->vtcam_list);
-	INIT_LIST_HEAD(&acl->uid.free_list);
+	idr_init(&acl->uid);
 
 	err = rhashtable_init(&acl->acl_rule_entry_ht,
 			      &__prestera_acl_rule_entry_ht_params);
@@ -1279,7 +1237,7 @@ void prestera_acl_fini(struct prestera_switch *sw)
 	struct prestera_acl *acl = sw->acl;
 
 	prestera_ct_clean(acl->ct_priv);
-	prestera_acl_uid_destroy(acl);
+	idr_destroy(&acl->uid);
 
 	WARN_ON(!list_empty(&acl->vtcam_list));
 	WARN_ON(!list_empty(&acl->nat_port_list));
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_acl.h b/drivers/net/ethernet/marvell/prestera/prestera_acl.h
index 2a50d9b..c8f4ceb 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_acl.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera_acl.h
@@ -115,6 +115,10 @@ struct prestera_acl_rule_entry {
 			u32 id;
 			struct prestera_counter_block *block;
 		} counter;
+		struct {
+			u8 valid:1;
+			struct prestera_acl_action_remark i;
+		} remark;
 	};
 };
 
@@ -150,8 +154,12 @@ struct prestera_acl_rule_entry_arg {
 		} nh;
 		struct {
 			u8 valid:1, fail_on_err:1;
-			enum prestera_counter_client client;
+			u32 client;
 		} count;
+		struct {
+			u8 valid:1;
+			struct prestera_acl_action_remark i;
+		} remark;
 	};
 };
 
@@ -176,10 +184,7 @@ struct prestera_acl {
 	/* TODO: move nh_mangle_entry_ht to router ? */
 	struct rhashtable nh_mangle_entry_ht;
 	struct prestera_ct_priv *ct_priv;
-	struct {
-		struct list_head free_list;
-		u8 next;
-	} uid;
+	struct idr uid;
 };
 
 struct prestera_acl_nat_port {
@@ -260,7 +265,7 @@ struct prestera_acl_rule_entry *
 prestera_acl_rule_entry_create(struct prestera_acl *acl,
 			       struct prestera_acl_rule_entry_key *key,
 			       struct prestera_acl_rule_entry_arg *arg);
-enum prestera_counter_client prestera_acl_chain_to_client(u32 chain_index);
+int prestera_acl_chain_to_client(u32 chain_index, u32 *client);
 struct prestera_acl_ruleset *
 prestera_acl_ruleset_get(struct prestera_acl *acl,
 			 struct prestera_flow_block *block,
@@ -282,11 +287,7 @@ int prestera_acl_ruleset_unbind(struct prestera_acl_ruleset *ruleset,
 void
 prestera_acl_rule_keymask_pcl_id_set(struct prestera_acl_rule *rule,
 				     u16 pcl_id);
-
-int prestera_acl_uid_new_get(struct prestera_acl *acl, u8 *uid);
-int prestera_acl_uid_release(struct prestera_acl *acl, u8 uid);
-
-int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup,
+int prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup, u8 dir,
 			      void *keymask, u32 *vtcam_id);
 int prestera_acl_vtcam_id_put(struct prestera_acl *acl, u32 vtcam_id);
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_counter.c b/drivers/net/ethernet/marvell/prestera/prestera_counter.c
index ee4ac8c..7020c03 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_counter.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_counter.c
@@ -26,7 +26,7 @@ struct prestera_counter_block {
 	u32 id;
 	u32 offset;
 	u32 num_counters;
-	enum prestera_counter_client client;
+	u32 client;
 	struct idr counter_idr;
 	bool full;
 	bool is_updating;
@@ -87,7 +87,7 @@ static void prestera_counter_stats_clear(struct prestera_counter_block *block,
 
 static struct prestera_counter_block *
 prestera_counter_block_lookup_not_full(struct prestera_counter *counter,
-				       enum prestera_counter_client client)
+				       u32 client)
 {
 	u32 i;
 
@@ -139,7 +139,7 @@ static int prestera_counter_block_list_add(struct prestera_counter *counter,
 
 static struct prestera_counter_block *
 prestera_counter_block_get(struct prestera_counter *counter,
-			   enum prestera_counter_client client)
+			   u32 client)
 {
 	struct prestera_counter_block *block;
 	int err;
@@ -248,8 +248,7 @@ static int prestera_counter_get_vacant(struct prestera_counter_block *block,
 	return 0;
 }
 
-int prestera_counter_get(struct prestera_counter *counter,
-			 enum prestera_counter_client client,
+int prestera_counter_get(struct prestera_counter *counter, u32 client,
 			 struct prestera_counter_block **bl, u32 *counter_id)
 {
 	struct prestera_counter_block *block;
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_counter.h b/drivers/net/ethernet/marvell/prestera/prestera_counter.h
index 009fa77..2d99a96 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_counter.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera_counter.h
@@ -6,14 +6,6 @@
 
 #include <linux/types.h>
 
-enum prestera_counter_client {
-	PRESTERA_COUNTER_CLIENT_LOOKUP_0,
-	PRESTERA_COUNTER_CLIENT_LOOKUP_1,
-	PRESTERA_COUNTER_CLIENT_LOOKUP_2,
-
-	PRESTERA_COUNTER_CLIENT_LOOKUP_LAST
-};
-
 struct prestera_counter_stats {
 	u64 packets;
 	u64 bytes;
@@ -24,8 +16,7 @@ struct prestera_counter_block;
 int prestera_counter_init(struct prestera_switch *sw);
 void prestera_counter_fini(struct prestera_switch *sw);
 
-int prestera_counter_get(struct prestera_counter *counter,
-			 enum prestera_counter_client client,
+int prestera_counter_get(struct prestera_counter *counter, u32 client,
 			 struct prestera_counter_block **block,
 			 u32 *counter_id);
 void prestera_counter_put(struct prestera_counter *counter,
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_ct.c b/drivers/net/ethernet/marvell/prestera/prestera_ct.c
index 524a50c..8cbb387 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_ct.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_ct.c
@@ -81,10 +81,10 @@ static int prestera_ct_chain_init(struct prestera_ct_priv *priv)
 	struct prestera_acl_rule_entry_arg re_arg;
 	struct prestera_acl_iface iface;
 	u16 pcl_id;
+	u32 uid = 0;
 	int err;
-	u8 uid;
 
-	err = prestera_acl_uid_new_get(priv->acl, &uid);
+	err = idr_alloc_u32(&priv->acl->uid, NULL, &uid, U8_MAX, GFP_KERNEL);
 	if (err)
 		return err;
 
@@ -100,6 +100,7 @@ static int prestera_ct_chain_init(struct prestera_ct_priv *priv)
 	rule_match_set_u16(re_key.match.mask, L4_PORT_DST, 0xFFFF);
 
 	err = prestera_acl_vtcam_id_get(priv->acl, PRESTERA_ACL_CT_CHAIN,
+					PRESTERA_HW_VTCAM_DIR_INGRESS,
 					re_key.match.mask, &priv->vtcam_id);
 	if (err)
 		goto err_vtcam_create;
@@ -143,7 +144,7 @@ static int prestera_ct_chain_init(struct prestera_ct_priv *priv)
 err_rule_entry_bind:
 	prestera_acl_vtcam_id_put(priv->acl, priv->vtcam_id);
 err_vtcam_create:
-	prestera_acl_uid_release(priv->acl, uid);
+	idr_remove(&priv->acl->uid, uid);
 	return err;
 }
 
@@ -180,8 +181,7 @@ void prestera_ct_clean(struct prestera_ct_priv *ct_priv)
 
 	prestera_acl_rule_entry_destroy(ct_priv->acl, ct_priv->re);
 	prestera_acl_vtcam_id_put(ct_priv->acl, ct_priv->vtcam_id);
-	prestera_acl_uid_release(ct_priv->acl, uid);
-
+	idr_remove(&ct_priv->acl->uid, uid);
 	rhashtable_destroy(&ct_priv->zone_ht);
 	kfree(ct_priv);
 }
@@ -479,13 +479,10 @@ prestera_ct_block_flow_offload_add(struct prestera_ct_ft *ft,
 	/* setup counter */
 	entry->tuple.re_arg.count.valid = true;
 	entry->tuple.re_arg.count.fail_on_err = true;
-	entry->tuple.re_arg.count.client =
-		prestera_acl_chain_to_client(PRESTERA_ACL_CT_CHAIN);
-	if (entry->tuple.re_arg.count.client ==
-	    PRESTERA_COUNTER_CLIENT_LOOKUP_LAST) {
-		err = -EINVAL;
+	err = prestera_acl_chain_to_client(PRESTERA_ACL_CT_CHAIN,
+					   &entry->tuple.re_arg.count.client);
+	if (err)
 		goto err_set;
-	}
 
 	err = __prestera_ct_tuple_get_nh(ft->ct_priv->acl->sw, &entry->tuple);
 	if (err)
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_dcb.c b/drivers/net/ethernet/marvell/prestera/prestera_dcb.c
new file mode 100644
index 0000000..76324fa
--- /dev/null
+++ b/drivers/net/ethernet/marvell/prestera/prestera_dcb.c
@@ -0,0 +1,407 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
+/* Copyright (c) 2021 Marvell International Ltd. All rights reserved */
+
+#include <linux/netdevice.h>
+#include <net/dcbnl.h>
+
+#include "prestera.h"
+#include "prestera_hw.h"
+#include "prestera_dcb.h"
+#include "prestera_acl.h"
+
+#define PRESTERA_ACL_QOS_REMARK_PRIO (0)
+#define PRESTERA_QOS_SP_TO_PROFILE_INDEX(__sp) ((__sp) | 0b1000)
+
+struct prestera_qos {
+	struct prestera_acl_rule_entry *rule[IEEE_8021QAZ_MAX_TCS];
+	bool bind;
+	u32 trust_mode;
+	u32 vtcam_id;
+	u8 uid;
+};
+
+struct prestera_acl_prio_dscp_map {
+	u32 dscp[IEEE_8021QAZ_MAX_TCS];
+};
+
+static int prestera_qos_remark_port_bind(struct prestera_port *port)
+{
+	struct prestera_acl *acl = port->sw->acl;
+	struct prestera_acl_iface iface;
+	struct prestera_acl_match match;
+	u32 vtcam_id;
+	int err = 0;
+	u32 uid = 0;
+	u32 pcl_id;
+
+	err = idr_alloc_u32(&acl->uid, NULL, &uid, U8_MAX, GFP_KERNEL);
+	if (err)
+		goto err_uid;
+
+	memset(&match, 0, sizeof(match));
+	rule_match_set_u16(match.mask, PCL_ID, PRESTERA_ACL_KEYMASK_PCL_ID);
+	rule_match_set_u8(match.mask, QOS_PROFILE, 0xff);
+
+	err = prestera_acl_vtcam_id_get(acl, 0, PRESTERA_HW_VTCAM_DIR_EGRESS,
+					match.mask, &vtcam_id);
+	if (err)
+		goto err_vtcam;
+
+	pcl_id = PRESTERA_ACL_PCL_ID_MAKE((u8)uid, 0);
+	iface.type = PRESTERA_ACL_IFACE_TYPE_PORT;
+	iface.port = port;
+
+	err = prestera_hw_vtcam_iface_bind(port->sw, &iface,
+					   vtcam_id, pcl_id);
+	if (err)
+		goto err_bind;
+
+	port->qos->uid = uid;
+	port->qos->vtcam_id = vtcam_id;
+	port->qos->bind = true;
+
+	return 0;
+err_bind:
+	prestera_acl_vtcam_id_put(acl, vtcam_id);
+err_vtcam:
+	idr_remove(&acl->uid, uid);
+err_uid:
+	return err;
+}
+
+static void prestera_qos_remark_port_unbind(struct prestera_port *port)
+{
+	struct prestera_acl *acl = port->sw->acl;
+	struct prestera_acl_iface iface = {
+		.type = PRESTERA_ACL_IFACE_TYPE_PORT,
+		.port = port
+	};
+
+	if (!port->qos->bind)
+		return;
+
+	WARN_ON(prestera_hw_vtcam_iface_unbind(port->sw, &iface,
+					       port->qos->vtcam_id));
+	WARN_ON(prestera_acl_vtcam_id_put(acl, port->qos->vtcam_id));
+	idr_remove(&acl->uid, port->qos->uid);
+
+	port->qos->bind = false;
+}
+
+static void prestera_qos_remark_rules_del(struct prestera_port *port)
+{
+	int i;
+
+	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+		if (!port->qos->rule[i])
+			continue;
+
+		prestera_acl_rule_entry_destroy(port->sw->acl,
+						port->qos->rule[i]);
+		port->qos->rule[i] = NULL;
+	}
+}
+
+static int prestera_qos_remark_rules_add(struct prestera_port *port,
+					 struct prestera_acl_prio_dscp_map *map)
+{
+	struct prestera_acl_rule_entry_key re_key;
+	struct prestera_acl_rule_entry_arg re_arg;
+	struct prestera_acl_rule_entry *re;
+	u32 pcl_id;
+	int err;
+	int i;
+
+	memset(&re_key, 0, sizeof(re_key));
+	memset(&re_arg, 0, sizeof(re_arg));
+
+	pcl_id = PRESTERA_ACL_PCL_ID_MAKE(port->qos->uid, 0);
+	re_key.prio = PRESTERA_ACL_QOS_REMARK_PRIO;
+	re_arg.remark.valid = 1;
+	re_arg.vtcam_id = port->qos->vtcam_id;
+
+	rule_match_set_u16(re_key.match.key, PCL_ID, pcl_id);
+	rule_match_set_u16(re_key.match.mask, PCL_ID,
+			   PRESTERA_ACL_KEYMASK_PCL_ID);
+	rule_match_set_u8(re_key.match.mask, QOS_PROFILE, 0xff);
+
+	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+		rule_match_set_u8(re_key.match.key, QOS_PROFILE,
+				  PRESTERA_QOS_SP_TO_PROFILE_INDEX(i));
+		re_arg.remark.i.dscp = map->dscp[i];
+
+		re = prestera_acl_rule_entry_create(port->sw->acl, &re_key,
+						    &re_arg);
+		err = !re ? -EINVAL : 0;
+		if (err)
+			goto err_rule_add;
+
+		port->qos->rule[i] = re;
+	}
+
+	return 0;
+
+err_rule_add:
+	prestera_qos_remark_rules_del(port);
+	return err;
+}
+
+static int prestera_dcb_app_validate(struct net_device *dev,
+				     struct dcb_app *app)
+{
+	int prio;
+
+	if (app->priority >= IEEE_8021QAZ_MAX_TCS) {
+		netdev_err(dev, "APP entry with priority value %u is invalid\n",
+			   app->priority);
+		return -EINVAL;
+	}
+
+	switch (app->selector) {
+	case IEEE_8021QAZ_APP_SEL_DSCP:
+		if (app->protocol >= 64) {
+			netdev_err(dev, "DSCP APP entry with protocol value %u is invalid\n",
+				   app->protocol);
+			return -EINVAL;
+		}
+
+		/* Warn about any DSCP APP entries with the same PID. */
+		prio = fls(dcb_ieee_getapp_mask(dev, app));
+		if (prio--) {
+			if (prio < app->priority)
+				netdev_warn(dev, "Choosing priority %d for DSCP %d in favor of previously-active value of %d\n",
+					    app->priority, app->protocol, prio);
+			else if (prio > app->priority)
+				netdev_warn(dev, "Ignoring new priority %d for DSCP %d in favor of current value of %d\n",
+					    app->priority, app->protocol, prio);
+		}
+		break;
+
+	case IEEE_8021QAZ_APP_SEL_ETHERTYPE:
+		if (app->protocol) {
+			netdev_err(dev, "EtherType APP entries with protocol value != 0 not supported\n");
+			return -EINVAL;
+		}
+		break;
+
+	default:
+		netdev_err(dev, "APP entries with selector %u not supported\n",
+			   app->selector);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static u8 prestera_dcb_port_default_prio(struct prestera_port *port)
+{
+	u8 prio_mask;
+
+	prio_mask = dcb_ieee_getapp_default_prio_mask(port->net_dev);
+	if (prio_mask)
+		/* Take the highest configured priority. */
+		return fls(prio_mask) - 1;
+
+	return 0;
+}
+
+static void prestera_dcb_port_dscp_prio_map(struct prestera_port *port,
+					    u8 default_prio,
+					    struct dcb_ieee_app_dscp_map *map)
+{
+	int i;
+
+	dcb_ieee_getapp_dscp_prio_mask_map(port->net_dev, map);
+	for (i = 0; i < ARRAY_SIZE(map->map); ++i) {
+		if (map->map[i])
+			map->map[i] = fls(map->map[i]) - 1;
+		else
+			map->map[i] = default_prio;
+	}
+}
+
+static bool prestera_dcb_port_prio_dscp_map(struct prestera_port *port,
+					    struct dcb_ieee_app_prio_map *map)
+{
+	bool have_dscp = false;
+	int i;
+
+	dcb_ieee_getapp_prio_dscp_mask_map(port->net_dev, map);
+	for (i = 0; i < ARRAY_SIZE(map->map); ++i) {
+		if (map->map[i]) {
+			map->map[i] = fls64(map->map[i]) - 1;
+			have_dscp = true;
+		}
+	}
+
+	return have_dscp;
+}
+
+static int prestera_port_trust_mode_set(struct prestera_port *port, u8 mode)
+{
+	int err;
+
+	err = prestera_hw_port_qos_trust_mode_set(port, mode);
+	if (err)
+		return err;
+
+	if (mode == PRESTERA_HW_QOS_TRUST_MODE_L3) {
+		err = prestera_qos_remark_port_bind(port);
+		if (err)
+			goto err_trust_mode;
+	} else {
+		prestera_qos_remark_rules_del(port);
+		prestera_qos_remark_port_unbind(port);
+	}
+
+	port->qos->trust_mode = mode;
+	return 0;
+
+err_trust_mode:
+	prestera_hw_port_qos_trust_mode_set(port, port->qos->trust_mode);
+	return err;
+}
+
+static int prestera_dcb_port_app_update(struct prestera_port *port,
+					struct dcb_app *app)
+{
+	struct prestera_acl_prio_dscp_map remark_map;
+	struct dcb_ieee_app_dscp_map dscp_map;
+	struct dcb_ieee_app_prio_map prio_map;
+	u8 default_prio;
+	bool have_dscp;
+	int err = 0;
+	u8 mode;
+	int i;
+
+	have_dscp = prestera_dcb_port_prio_dscp_map(port, &prio_map);
+
+	mode = have_dscp ? PRESTERA_HW_QOS_TRUST_MODE_L3 :
+			   PRESTERA_HW_QOS_TRUST_MODE_L2;
+
+	if (port->qos->trust_mode != mode) {
+		err = prestera_port_trust_mode_set(port, mode);
+		if (err) {
+			netdev_err(port->net_dev,
+				   "Failed to configure trust mode\n");
+			return err;
+		}
+	}
+
+	default_prio = prestera_dcb_port_default_prio(port);
+	prestera_dcb_port_dscp_prio_map(port, default_prio, &dscp_map);
+
+	err = prestera_hw_port_qos_default_prio_set(port, default_prio);
+	if (err) {
+		netdev_err(port->net_dev,
+			   "Failed to configure default priority\n");
+		return err;
+	}
+
+	if (mode != PRESTERA_HW_QOS_TRUST_MODE_L3)
+		return 0;
+
+	err = prestera_hw_port_qos_mapping_update(port, &dscp_map);
+	if (err) {
+		netdev_err(port->net_dev, "Failed to configure priority\n");
+		return err;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(remark_map.dscp); i++)
+		remark_map.dscp[i] = (u32)prio_map.map[i];
+
+	prestera_qos_remark_rules_del(port);
+	err = prestera_qos_remark_rules_add(port, &remark_map);
+	if (err) {
+		netdev_err(port->net_dev, "Failed to create remarking rules\n");
+		return err;
+	}
+
+	return err;
+}
+
+static int prestera_dcb_port_app_flush(struct prestera_port *port,
+				       struct dcb_app *app)
+{
+	int err;
+
+	err = prestera_hw_port_qos_default_prio_set(port, 0);
+	if (err) {
+		netdev_err(port->net_dev,
+			   "Failed to reset default priority\n");
+		return err;
+	}
+
+	err = prestera_port_trust_mode_set(port, PRESTERA_HW_QOS_TRUST_MODE_L2);
+	if (err) {
+		netdev_err(port->net_dev,
+			   "Failed to reset trust mode\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static int prestera_dcb_ieee_setapp(struct net_device *dev,
+				    struct dcb_app *app)
+{
+	struct prestera_port *port = netdev_priv(dev);
+	int err;
+
+	err = prestera_dcb_app_validate(dev, app);
+	if (err)
+		return err;
+
+	err = dcb_ieee_setapp(dev, app);
+	if (err)
+		return err;
+
+	err = prestera_dcb_port_app_update(port, app);
+	if (err)
+		dcb_ieee_delapp(dev, app);
+
+	return err;
+}
+
+static int prestera_dcb_ieee_delapp(struct net_device *dev,
+				    struct dcb_app *app)
+{
+	struct prestera_port *port = netdev_priv(dev);
+	int err;
+
+	err = dcb_ieee_delapp(dev, app);
+	if (err)
+		return err;
+
+	err = prestera_dcb_port_app_flush(port, app);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static const struct dcbnl_rtnl_ops prestera_dcbnl_ops = {
+	.ieee_setapp		= prestera_dcb_ieee_setapp,
+	.ieee_delapp		= prestera_dcb_ieee_delapp,
+};
+
+int prestera_port_dcb_init(struct prestera_port *port)
+{
+	port->qos = kzalloc(sizeof(*port->qos), GFP_KERNEL);
+	if (!port->qos)
+		return -ENOMEM;
+
+	port->net_dev->dcbnl_ops = &prestera_dcbnl_ops;
+	port->qos->trust_mode = PRESTERA_HW_QOS_TRUST_MODE_L2;
+
+	return 0;
+}
+
+void prestera_port_dcb_fini(struct prestera_port *port)
+{
+	prestera_qos_remark_rules_del(port);
+	prestera_qos_remark_port_unbind(port);
+	kfree(port->qos);
+
+	port->net_dev->dcbnl_ops = NULL;
+}
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_dcb.h b/drivers/net/ethernet/marvell/prestera/prestera_dcb.h
new file mode 100644
index 0000000..6348534
--- /dev/null
+++ b/drivers/net/ethernet/marvell/prestera/prestera_dcb.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
+/* Copyright (c) 2022 Marvell International Ltd. All rights reserved. */
+
+#ifndef _PRESTERA_DCB_H_
+#define _PRESTERA_DCB_H_
+
+#include <linux/types.h>
+
+struct prestera_port;
+
+int prestera_port_dcb_init(struct prestera_port *port);
+void prestera_port_dcb_fini(struct prestera_port *port);
+
+#endif /* _PRESTERA_DCB_H_ */
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_drv_ver.h b/drivers/net/ethernet/marvell/prestera/prestera_drv_ver.h
index 2c0d754..b2ffa44 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_drv_ver.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera_drv_ver.h
@@ -10,7 +10,7 @@
 #define PRESTERA_DRV_VER_MAJOR	2
 #define PRESTERA_DRV_VER_MINOR	0
 #define PRESTERA_DRV_VER_PATCH	0
-#define PRESTERA_DRV_VER_EXTRA	-v3.1.1
+#define PRESTERA_DRV_VER_EXTRA
 
 #define PRESTERA_DRV_VER \
 		__stringify(PRESTERA_DRV_VER_MAJOR)  "." \
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_ethtool.c b/drivers/net/ethernet/marvell/prestera/prestera_ethtool.c
index 531eb58..2ddf22c 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_ethtool.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_ethtool.c
@@ -345,32 +345,6 @@ static void prestera_port_mdix_cache(struct prestera_port *port)
 	}
 }
 
-static void prestera_port_link_mode_cache(struct prestera_port *port)
-{
-	struct prestera_port_mac_state *state = &port->state_mac;
-	u32 speed;
-	u8 duplex;
-	int err;
-
-	if (!port->state_mac.oper)
-		return;
-
-	if (state->speed == SPEED_UNKNOWN ||
-	    state->duplex == DUPLEX_UNKNOWN) {
-
-		err = prestera_hw_port_mac_mode_get(port, NULL, &speed,
-						    &duplex, NULL);
-		if (err) {
-			state->speed = SPEED_UNKNOWN;
-			state->duplex = DUPLEX_UNKNOWN;
-		} else {
-			state->speed = speed;
-			state->duplex = duplex == PRESTERA_PORT_DUPLEX_FULL ?
-					  DUPLEX_FULL : DUPLEX_HALF;
-		}
-	}
-}
-
 static void prestera_port_mdix_get(struct ethtool_link_ksettings *ecmd,
 				   struct prestera_port *port)
 {
@@ -562,10 +536,20 @@ static void prestera_port_supp_types_get(struct ethtool_link_ksettings *ecmd,
 static void prestera_port_link_mode_get(struct ethtool_link_ksettings *ecmd,
 					struct prestera_port *port)
 {
-	prestera_port_link_mode_cache(port);
+	struct prestera_port_mac_state state;
+
+	/* We don't need explicity read state from FW,
+	 * because there are events
+	 */
+	prestera_port_mac_state_cache_read(port, &state);
 
-	ecmd->base.speed = port->state_mac.speed;
-	ecmd->base.duplex = port->state_mac.duplex;
+	if (state.valid) {
+		ecmd->base.speed = state.speed;
+		ecmd->base.duplex = state.duplex;
+	} else {
+		ecmd->base.speed = SPEED_UNKNOWN;
+		ecmd->base.duplex = DUPLEX_UNKNOWN;
+	}
 }
 
 static void prestera_port_get_drvinfo(struct net_device *dev,
@@ -679,20 +663,19 @@ static int prestera_port_get_link_ksettings(struct net_device *dev,
 #endif /* CONFIG_PHYLINK */
 
 	prestera_port_supp_types_get(ecmd, port);
-
 	prestera_port_autoneg_get(ecmd, port);
-
-	if (port->autoneg && netif_carrier_ok(dev) &&
-	    port->caps.transceiver == PRESTERA_PORT_TCVR_COPPER)
-		prestera_port_remote_cap_get(ecmd, port);
+	prestera_port_type_get(ecmd, port);
 
 	if (netif_carrier_ok(dev))
 		prestera_port_link_mode_get(ecmd, port);
 
-	prestera_port_type_get(ecmd, port);
+	if (port->caps.transceiver == PRESTERA_PORT_TCVR_SFP)
+		return 0;
+
+	if (port->autoneg && netif_carrier_ok(dev))
+		prestera_port_remote_cap_get(ecmd, port);
 
-	if (port->caps.type == PRESTERA_PORT_TYPE_TP &&
-	    port->caps.transceiver == PRESTERA_PORT_TCVR_COPPER)
+	if (port->caps.type == PRESTERA_PORT_TYPE_TP)
 		prestera_port_mdix_get(ecmd, port);
 
 	return 0;
@@ -703,6 +686,7 @@ static int prestera_port_set_link_ksettings(struct net_device *dev,
 					    *ecmd)
 {
 	struct prestera_port *port = netdev_priv(dev);
+	struct prestera_port_mac_config cfg_mac;
 	u64 adver_modes = 0;
 	u8 adver_fec = 0;
 	int err;
@@ -716,12 +700,32 @@ static int prestera_port_set_link_ksettings(struct net_device *dev,
 	if (err)
 		return err;
 
-	if (port->caps.transceiver == PRESTERA_PORT_TCVR_COPPER) {
-		err = prestera_port_mdix_set(ecmd, port);
-		if (err)
-			return err;
+	if (port->caps.transceiver == PRESTERA_PORT_TCVR_SFP) {
+		prestera_port_cfg_mac_read(port, &cfg_mac);
+		switch (ecmd->base.speed) {
+		case SPEED_1000:
+			cfg_mac.mode = PRESTERA_MAC_MODE_1000BASE_X;
+			cfg_mac.inband = false;
+			break;
+		case SPEED_10000:
+			cfg_mac.mode = PRESTERA_MAC_MODE_SR_LR;
+			cfg_mac.speed = SPEED_10000;
+			cfg_mac.inband = false;
+			break;
+		default:
+			cfg_mac.mode = PRESTERA_MAC_MODE_SGMII;
+			cfg_mac.speed = 0;
+			cfg_mac.duplex = DUPLEX_UNKNOWN;
+			cfg_mac.inband = true;
+		}
+
+		return prestera_port_cfg_mac_write(port, &cfg_mac);
 	}
 
+	err = prestera_port_mdix_set(ecmd, port);
+	if (err)
+		return err;
+
 	if (ecmd->base.autoneg == AUTONEG_ENABLE) {
 		if (prestera_modes_from_eth(port, ecmd->link_modes.advertising,
 					    ecmd->link_modes.supported,
@@ -863,28 +867,6 @@ static void prestera_port_get_strings(struct net_device *dev,
 	memcpy(data, *prestera_port_cnt_name, sizeof(prestera_port_cnt_name));
 }
 
-void prestera_ethtool_port_state_changed(struct prestera_port *port,
-					 struct prestera_port_event *evt)
-{
-	struct prestera_port_mac_state *smac = &port->state_mac;
-
-	smac->oper = evt->data.mac.oper;
-
-	if (smac->oper) {
-		smac->mode = evt->data.mac.mode;
-		smac->speed = evt->data.mac.speed;
-		smac->duplex = evt->data.mac.duplex;
-		smac->fc = evt->data.mac.fc;
-		smac->fec = evt->data.mac.fec;
-	} else {
-		smac->mode = PRESTERA_MAC_MODE_MAX;
-		smac->speed = SPEED_UNKNOWN;
-		smac->duplex = DUPLEX_UNKNOWN;
-		smac->fc = 0;
-		smac->fec = 0;
-	}
-}
-
 const struct ethtool_ops prestera_ethtool_ops = {
 	.get_drvinfo = prestera_port_get_drvinfo,
 	.get_link_ksettings = prestera_port_get_link_ksettings,
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_ethtool.h b/drivers/net/ethernet/marvell/prestera/prestera_ethtool.h
index 18c6022..83b2b47 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_ethtool.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera_ethtool.h
@@ -13,7 +13,4 @@ extern const struct ethtool_ops prestera_ethtool_ops;
 int prestera_port_link_mode_set(struct prestera_port *port,
 				u32 speed, u8 duplex, u8 type);
 
-void prestera_ethtool_port_state_changed(struct prestera_port *port,
-					 struct prestera_port_event *evt);
-
 #endif /* _PRESTERA_ETHTOOL_H_ */
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_fw.c b/drivers/net/ethernet/marvell/prestera/prestera_fw.c
new file mode 100644
index 0000000..6da3aa8
--- /dev/null
+++ b/drivers/net/ethernet/marvell/prestera/prestera_fw.c
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
+/* Copyright (c) 2019-2021 Marvell International Ltd. All rights reserved */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/circ_buf.h>
+
+#include "prestera.h"
+#include "prestera_fw.h"
+
+#define PRESTERA_FW_READY_MAGIC	0xcafebabe
+
+/* Firmware registers: */
+#define PRESTERA_FW_READY_REG		PRESTERA_FW_REG_OFFSET(fw_ready)
+
+#define PRESTERA_CMDQ_REG_OFFSET(q, f)			\
+	(PRESTERA_FW_REG_OFFSET(cmdq_list) +		\
+	 (q) * sizeof(struct prestera_fw_cmdq_regs) +	\
+	 offsetof(struct prestera_fw_cmdq_regs, f))
+
+#define PRESTERA_CMD_BUF_OFFS_REG	PRESTERA_FW_REG_OFFSET(cmd_offs)
+#define PRESTERA_CMD_BUF_LEN_REG	PRESTERA_FW_REG_OFFSET(cmd_len)
+#define PRESTERA_CMD_QNUM_REG		PRESTERA_FW_REG_OFFSET(cmd_qnum)
+#define PRESTERA_EVT_BUF_OFFS_REG	PRESTERA_FW_REG_OFFSET(evt_offs)
+#define PRESTERA_EVT_QNUM_REG		PRESTERA_FW_REG_OFFSET(evt_qnum)
+
+#define PRESTERA_CMDQ_REQ_CTL_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_req_ctl)
+#define PRESTERA_CMDQ_REQ_LEN_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_req_len)
+#define PRESTERA_CMDQ_RCV_CTL_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_rcv_ctl)
+#define PRESTERA_CMDQ_RCV_LEN_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_rcv_len)
+#define PRESTERA_CMDQ_OFFS_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, offs)
+#define PRESTERA_CMDQ_LEN_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, len)
+
+/* PRESTERA_CMDQ_REQ_CTL_REG flags */
+#define PRESTERA_CMD_F_REQ_SENT		BIT(0)
+#define PRESTERA_CMD_F_REPL_RCVD	BIT(1)
+
+/* PRESTERA_CMDQ_RCV_CTL_REG flags */
+#define PRESTERA_CMD_F_REPL_SENT	BIT(0)
+
+/* PRESTERA_FW_STATUS_REG flags */
+#define PRESTERA_STATUS_F_EVT_OFF	BIT(0)
+
+#define PRESTERA_EVTQ_REG_OFFSET(q, f)			\
+	(PRESTERA_FW_REG_OFFSET(evtq_list) +		\
+	 (q) * sizeof(struct prestera_fw_evtq_regs) +	\
+	 offsetof(struct prestera_fw_evtq_regs, f))
+
+#define PRESTERA_EVTQ_RD_IDX_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, rd_idx)
+#define PRESTERA_EVTQ_WR_IDX_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, wr_idx)
+#define PRESTERA_EVTQ_OFFS_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, offs)
+#define PRESTERA_EVTQ_LEN_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, len)
+
+#define FW_VER_MAJ_MUL 1000000
+#define FW_VER_MIN_MUL 1000
+
+static int fw_ver_maj(int v)
+{
+	return ((v) / FW_VER_MAJ_MUL);
+}
+
+static int fw_ver_min(int v)
+{
+	int vv = fw_ver_maj(v) * FW_VER_MAJ_MUL;
+
+	return (((v) - vv) / FW_VER_MIN_MUL);
+}
+
+static int fw_ver_patch(int v)
+{
+	int vv, vvv;
+
+	vv = (fw_ver_maj(v) * FW_VER_MAJ_MUL);
+	vvv = (fw_ver_min(v) * FW_VER_MIN_MUL);
+	return ((v) - vv - vvv);
+}
+
+static void prestera_fw_cmdq_lock(struct prestera_fw *fw, u8 qid)
+{
+	mutex_lock(&fw->cmd_queue[qid].cmd_mtx);
+}
+
+static void prestera_fw_cmdq_unlock(struct prestera_fw *fw, u8 qid)
+{
+	mutex_unlock(&fw->cmd_queue[qid].cmd_mtx);
+}
+
+static u32 prestera_fw_cmdq_len(struct prestera_fw *fw, u8 qid)
+{
+	return fw->cmd_queue[qid].len;
+}
+
+static u8 __iomem *prestera_fw_cmdq_buf(struct prestera_fw *fw, u8 qid)
+{
+	return fw->cmd_queue[qid].addr;
+}
+
+static u32 prestera_fw_evtq_len(struct prestera_fw *fw, u8 qid)
+{
+	return fw->evt_queue[qid].len;
+}
+
+static u32 prestera_fw_evtq_avail(struct prestera_fw *fw, u8 qid)
+{
+	u32 wr_idx = prestera_fw_read(fw, PRESTERA_EVTQ_WR_IDX_REG(qid));
+	u32 rd_idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
+
+	return CIRC_CNT(wr_idx, rd_idx, prestera_fw_evtq_len(fw, qid));
+}
+
+static void prestera_fw_evtq_rd_set(struct prestera_fw *fw, u8 qid, u32 idx)
+{
+	u32 rd_idx = idx & (prestera_fw_evtq_len(fw, qid) - 1);
+
+	prestera_fw_write(fw, PRESTERA_EVTQ_RD_IDX_REG(qid), rd_idx);
+}
+
+static u8 __iomem *prestera_fw_evtq_buf(struct prestera_fw *fw, u8 qid)
+{
+	return fw->evt_queue[qid].addr;
+}
+
+static u32 prestera_fw_evtq_read32(struct prestera_fw *fw, u8 qid)
+{
+	u32 rd_idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
+	u32 val;
+
+	val = readl(prestera_fw_evtq_buf(fw, qid) + rd_idx);
+	prestera_fw_evtq_rd_set(fw, qid, rd_idx + 4);
+	return val;
+}
+
+static ssize_t prestera_fw_evtq_read_buf(struct prestera_fw *fw, u8 qid,
+					 u8 *buf, size_t len)
+{
+	u32 idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
+	u8 __iomem *evtq_addr = prestera_fw_evtq_buf(fw, qid);
+	u32 *buf32 = (u32 *)buf;
+	int i;
+
+	for (i = 0; i < len / 4; buf32++, i++) {
+		*buf32 = readl_relaxed(evtq_addr + idx);
+		idx = (idx + 4) & (prestera_fw_evtq_len(fw, qid) - 1);
+	}
+
+	prestera_fw_evtq_rd_set(fw, qid, idx);
+
+	return i;
+}
+
+static u8 prestera_fw_evtq_pick(struct prestera_fw *fw)
+{
+	int qid;
+
+	for (qid = 0; qid < fw->evt_qnum; qid++) {
+		if (prestera_fw_evtq_avail(fw, qid) >= 4)
+			return qid;
+	}
+
+	return PRESTERA_EVT_QNUM_MAX;
+}
+
+static void prestera_fw_status_set(struct prestera_fw *fw, unsigned int val)
+{
+	u32 status = prestera_fw_read(fw, PRESTERA_FW_STATUS_REG);
+
+	status |= val;
+
+	prestera_fw_write(fw, PRESTERA_FW_STATUS_REG, status);
+}
+
+static void prestera_fw_status_clear(struct prestera_fw *fw, u32 val)
+{
+	u32 status = prestera_fw_read(fw, PRESTERA_FW_STATUS_REG);
+
+	status &= ~val;
+
+	prestera_fw_write(fw, PRESTERA_FW_STATUS_REG, status);
+}
+
+void prestera_fw_handle_event(struct prestera_fw *fw)
+{
+	u8 *msg;
+	u8 qid;
+
+	msg = fw->evt_msg;
+
+	prestera_fw_status_set(fw, PRESTERA_STATUS_F_EVT_OFF);
+
+	while ((qid = prestera_fw_evtq_pick(fw)) < PRESTERA_EVT_QNUM_MAX) {
+		u32 idx;
+		u32 len;
+
+		len = prestera_fw_evtq_read32(fw, qid);
+		idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
+
+		WARN_ON(prestera_fw_evtq_avail(fw, qid) < len);
+
+		if (WARN_ON(len > PRESTERA_MSG_MAX_SIZE)) {
+			prestera_fw_evtq_rd_set(fw, qid, idx + len);
+			continue;
+		}
+
+		prestera_fw_evtq_read_buf(fw, qid, msg, len);
+
+		if (fw->dev.recv_msg)
+			fw->dev.recv_msg(&fw->dev, msg, len);
+	}
+
+	prestera_fw_status_clear(fw, PRESTERA_STATUS_F_EVT_OFF);
+}
+EXPORT_SYMBOL(prestera_fw_handle_event);
+
+static void prestera_fw_evt_work_fn(struct work_struct *work)
+{
+	struct prestera_fw *fw;
+
+	fw = container_of(work, struct prestera_fw, evt_work);
+
+	prestera_fw_handle_event(fw);
+}
+
+void prestera_fw_queue_work(struct prestera_fw *fw)
+{
+	queue_work(fw->wq, &fw->evt_work);
+}
+EXPORT_SYMBOL(prestera_fw_queue_work);
+
+static int prestera_fw_wait_reg32(struct prestera_fw *fw, u32 reg, u32 val,
+				  unsigned int wait)
+{
+	if (prestera_wait(prestera_fw_read(fw, reg) == val || !fw->dev.running,
+			  wait))
+		return fw->dev.running ? 0 : -ENODEV;
+
+	return -EBUSY;
+}
+
+static void prestera_pci_copy_to(u8 __iomem *dst, u8 *src, size_t len)
+{
+	u32 __iomem *dst32 = (u32 __iomem *)dst;
+	u32 *src32 = (u32 *)src;
+	int i;
+
+	for (i = 0; i < (len / 4); dst32++, src32++, i++)
+		writel_relaxed(*src32, dst32);
+}
+
+static void prestera_pci_copy_from(u8 *dst, u8 __iomem *src, size_t len)
+{
+	u32 *dst32 = (u32 *)dst;
+	u32 __iomem *src32 = (u32 __iomem *)src;
+	int i;
+
+	for (i = 0; i < (len / 4); dst32++, src32++, i++)
+		*dst32 = readl_relaxed(src32);
+}
+
+static int prestera_fw_cmd_send(struct prestera_fw *fw, int qid,
+				u8 *in_msg, size_t in_size,
+				u8 *out_msg, size_t out_size,
+				unsigned int wait)
+{
+	u32 ret_size = 0;
+	int err = 0;
+
+	if (!wait)
+		wait = 30000;
+
+	if (ALIGN(in_size, 4) > prestera_fw_cmdq_len(fw, qid))
+		return -EMSGSIZE;
+
+	/* wait for finish previous reply from FW */
+	err = prestera_fw_wait_reg32(fw, PRESTERA_CMDQ_RCV_CTL_REG(qid),
+				     0, 1000);
+	if (err) {
+		dev_err(prestera_fw_dev(fw),
+			"finish reply from FW is timed out\n");
+		return err;
+	}
+
+	prestera_fw_write(fw, PRESTERA_CMDQ_REQ_LEN_REG(qid), in_size);
+	prestera_pci_copy_to(prestera_fw_cmdq_buf(fw, qid), in_msg, in_size);
+
+	prestera_fw_write(fw, PRESTERA_CMDQ_REQ_CTL_REG(qid),
+			  PRESTERA_CMD_F_REQ_SENT);
+
+	/* wait for reply from FW */
+	err = prestera_fw_wait_reg32(fw, PRESTERA_CMDQ_RCV_CTL_REG(qid),
+				     PRESTERA_CMD_F_REPL_SENT, wait);
+	if (err) {
+		dev_err(prestera_fw_dev(fw),
+			"reply from FW is timed out\n");
+		goto cmd_exit;
+	}
+
+	ret_size = prestera_fw_read(fw, PRESTERA_CMDQ_RCV_LEN_REG(qid));
+	if (ret_size > out_size) {
+		dev_err(prestera_fw_dev(fw), "ret_size (%u) > out_len(%zu)\n",
+			ret_size, out_size);
+		err = -EMSGSIZE;
+		goto cmd_exit;
+	}
+
+	prestera_pci_copy_from(out_msg, prestera_fw_cmdq_buf(fw, qid) + in_size,
+			       ret_size);
+
+cmd_exit:
+	prestera_fw_write(fw, PRESTERA_CMDQ_REQ_CTL_REG(qid),
+			  PRESTERA_CMD_F_REPL_RCVD);
+	return err;
+}
+
+int prestera_fw_send_req(struct prestera_device *pr_dev, int qid,
+			 u8 *in_msg, size_t in_size, u8 *out_msg,
+			 size_t out_size, unsigned int wait)
+{
+	struct prestera_fw *fw;
+	ssize_t ret;
+
+	fw = container_of(pr_dev, struct prestera_fw, dev);
+
+	if (!fw->dev.running)
+		return -ENODEV;
+
+	prestera_fw_cmdq_lock(fw, qid);
+	ret = prestera_fw_cmd_send(fw, qid, in_msg, in_size, out_msg, out_size,
+				   wait);
+	prestera_fw_cmdq_unlock(fw, qid);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(prestera_fw_send_req);
+
+int prestera_fw_rev_check(struct prestera_fw *fw)
+{
+	struct prestera_fw_rev *rev = &fw->dev.fw_rev;
+
+	dev_info(prestera_fw_dev(fw), "FW version '%u.%u.%u'\n",
+		 rev->maj, rev->min, rev->sub);
+	dev_info(prestera_fw_dev(fw), "Driver version '%u.%u.%u'\n",
+		 PRESTERA_SUPP_FW_MAJ_VER, PRESTERA_SUPP_FW_MIN_VER,
+		 PRESTERA_SUPP_FW_PATCH_VER);
+
+	if (rev->maj == PRESTERA_SUPP_FW_MAJ_VER &&
+	    rev->min == PRESTERA_SUPP_FW_MIN_VER) {
+		return 0;
+	}
+
+	dev_err(prestera_fw_dev(fw),
+		"Driver is incomatible with FW: version mismatch");
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(prestera_fw_rev_check);
+
+void prestera_fw_rev_parse(const struct prestera_fw_header *hdr,
+			   struct prestera_fw_rev *rev)
+{
+	u32 version = be32_to_cpu(hdr->version_value);
+
+	rev->maj = fw_ver_maj(version);
+	rev->min = fw_ver_min(version);
+	rev->sub = fw_ver_patch(version);
+}
+EXPORT_SYMBOL_GPL(prestera_fw_rev_parse);
+
+void prestera_fw_rev_parse_int(unsigned int firmware_version,
+			       struct prestera_fw_rev *rev)
+{
+	u32 version = firmware_version;
+
+	rev->maj = fw_ver_maj(version);
+	rev->min = fw_ver_min(version);
+	rev->sub = fw_ver_patch(version);
+}
+EXPORT_SYMBOL_GPL(prestera_fw_rev_parse_int);
+
+int prestera_fw_init(struct prestera_fw *fw)
+{
+	u8 __iomem *base;
+	int err;
+	u8 qid;
+
+	err = prestera_fw_wait_reg32(fw, PRESTERA_FW_READY_REG,
+				     PRESTERA_FW_READY_MAGIC, 20000);
+	if (err) {
+		dev_err(prestera_fw_dev(fw), "FW failed to start\n");
+		return err;
+	}
+
+	base = fw->mem_addr;
+
+	fw->cmd_mbox = base + prestera_fw_read(fw, PRESTERA_CMD_BUF_OFFS_REG);
+	fw->cmd_mbox_len = prestera_fw_read(fw, PRESTERA_CMD_BUF_LEN_REG);
+	fw->cmd_qnum = prestera_fw_read(fw, PRESTERA_CMD_QNUM_REG);
+
+	for (qid = 0; qid < fw->cmd_qnum; qid++) {
+		u32 offs = prestera_fw_read(fw, PRESTERA_CMDQ_OFFS_REG(qid));
+		struct prestera_fw_cmdq *cmdq = &fw->cmd_queue[qid];
+
+		cmdq->len = prestera_fw_read(fw, PRESTERA_CMDQ_LEN_REG(qid));
+		cmdq->addr = fw->cmd_mbox + offs;
+		mutex_init(&cmdq->cmd_mtx);
+	}
+
+	fw->evt_buf = base + prestera_fw_read(fw, PRESTERA_EVT_BUF_OFFS_REG);
+	fw->evt_qnum = prestera_fw_read(fw, PRESTERA_EVT_QNUM_REG);
+	fw->evt_msg = kmalloc(PRESTERA_MSG_MAX_SIZE, GFP_KERNEL);
+	if (!fw->evt_msg)
+		return -ENOMEM;
+
+	for (qid = 0; qid < fw->evt_qnum; qid++) {
+		u32 offs = prestera_fw_read(fw, PRESTERA_EVTQ_OFFS_REG(qid));
+		struct prestera_fw_evtq *evtq = &fw->evt_queue[qid];
+
+		evtq->len = prestera_fw_read(fw, PRESTERA_EVTQ_LEN_REG(qid));
+		evtq->addr = fw->evt_buf + offs;
+	}
+
+	fw->wq = alloc_workqueue("prestera_fw_wq", WQ_HIGHPRI, 1);
+	if (!fw->wq)
+		goto err_wq_alloc;
+
+	INIT_WORK(&fw->evt_work, prestera_fw_evt_work_fn);
+
+	return 0;
+
+err_wq_alloc:
+	kfree(fw->evt_msg);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(prestera_fw_init);
+
+void prestera_fw_uninit(struct prestera_fw *fw)
+{
+	kfree(fw->evt_msg);
+	flush_workqueue(fw->wq);
+	destroy_workqueue(fw->wq);
+}
+EXPORT_SYMBOL_GPL(prestera_fw_uninit);
+
+MODULE_AUTHOR("Marvell Semi.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Marvell Prestera switch Firmware Agent interface");
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_fw.h b/drivers/net/ethernet/marvell/prestera/prestera_fw.h
new file mode 100644
index 0000000..9a5f915
--- /dev/null
+++ b/drivers/net/ethernet/marvell/prestera/prestera_fw.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
+/* Copyright (c) 2019-2021 Marvell International Ltd. All rights reserved */
+
+#ifndef PRESTERA_FW_H
+#define PRESTERA_FW_H_
+
+#define PRESTERA_EVT_QNUM_MAX	4
+#define PRESTERA_CMD_QNUM_MAX	4
+
+struct prestera_fw_evtq_regs {
+	u32 rd_idx;
+	u32 pad1;
+	u32 wr_idx;
+	u32 pad2;
+	u32 offs;
+	u32 len;
+};
+
+struct prestera_fw_cmdq_regs {
+	u32 cmd_req_ctl;
+	u32 cmd_req_len;
+	u32 cmd_rcv_ctl;
+	u32 cmd_rcv_len;
+	u32 offs;
+	u32 len;
+};
+
+struct prestera_fw_regs {
+	u32 fw_ready;
+	u32 cmd_offs;
+	u32 cmd_len;
+	u32 cmd_qnum;
+	u32 evt_offs;
+	u32 evt_qnum;
+
+	u32 fw_status;
+	u32 rx_status;
+
+	struct prestera_fw_cmdq_regs cmdq_list[PRESTERA_CMD_QNUM_MAX];
+	struct prestera_fw_evtq_regs evtq_list[PRESTERA_EVT_QNUM_MAX];
+};
+
+#define prestera_wait(cond, waitms) \
+({ \
+	unsigned long __wait_end = jiffies + msecs_to_jiffies(waitms); \
+	bool __wait_ret = false; \
+	do { \
+		if (cond) { \
+			__wait_ret = true; \
+			break; \
+		} \
+		cond_resched(); \
+	} while (time_before(jiffies, __wait_end)); \
+	__wait_ret; \
+})
+
+#define prestera_fw_dev(fw)	((fw)->dev.dev)
+
+/* Firmware registers: */
+#define PRESTERA_FW_REG_OFFSET(f)	offsetof(struct prestera_fw_regs, f)
+
+#define PRESTERA_FW_STATUS_REG		PRESTERA_FW_REG_OFFSET(fw_status)
+#define PRESTERA_RX_STATUS_REG		PRESTERA_FW_REG_OFFSET(rx_status)
+
+#define prestera_fw_write(fw, reg, val)	writel(val, (fw)->hw_regs + (reg))
+#define prestera_fw_read(fw, reg)	readl((fw)->hw_regs + (reg))
+
+#define PRESTERA_SUPP_FW_MAJ_VER	3
+#define PRESTERA_SUPP_FW_MIN_VER	1
+#define PRESTERA_SUPP_FW_PATCH_VER	1
+
+struct prestera_fw_evtq {
+	u8 __iomem *addr;
+	size_t len;
+};
+
+struct prestera_fw_cmdq {
+	/* serialize access to dev->send_req */
+	struct mutex cmd_mtx;
+	u8 __iomem *addr;
+	size_t len;
+};
+
+struct prestera_fw_header {
+	__be32 magic_number;
+	__be32 version_value;
+	u8 reserved[8];
+} __packed;
+
+struct prestera_fw {
+	struct workqueue_struct *wq;
+	struct prestera_device dev;
+	struct pci_dev *pci_dev;
+	u8 __iomem *mem_addr;
+
+	u8 __iomem *ldr_regs;
+	u8 __iomem *hw_regs;
+
+	u8 __iomem *ldr_ring_buf;
+	u32 ldr_buf_len;
+	u32 ldr_wr_idx;
+
+	size_t cmd_mbox_len;
+	u8 __iomem *cmd_mbox;
+	struct prestera_fw_cmdq cmd_queue[PRESTERA_CMD_QNUM_MAX];
+	u8 cmd_qnum;
+	struct prestera_fw_evtq evt_queue[PRESTERA_EVT_QNUM_MAX];
+	u8 evt_qnum;
+	struct work_struct evt_work;
+	u8 __iomem *evt_buf;
+	u8 *evt_msg;
+};
+
+int prestera_fw_rev_check(struct prestera_fw *fw);
+void prestera_fw_rev_parse_int(unsigned int firmware_version,
+			       struct prestera_fw_rev *rev);
+void prestera_fw_rev_parse(const struct prestera_fw_header *hdr,
+			   struct prestera_fw_rev *rev);
+void prestera_fw_uninit(struct prestera_fw *fw);
+int prestera_fw_init(struct prestera_fw *fw);
+int prestera_fw_send_req(struct prestera_device *dev, int qid,
+			 u8 *in_msg, size_t in_size, u8 *out_msg,
+			 size_t out_size, unsigned int wait);
+void prestera_fw_handle_event(struct prestera_fw *fw);
+void prestera_fw_queue_work(struct prestera_fw *fw);
+
+#endif
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_hw.c b/drivers/net/ethernet/marvell/prestera/prestera_hw.c
index 4c18d3f..f476e3e 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_hw.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_hw.c
@@ -5,6 +5,7 @@
 #include <linux/ethtool.h>
 #include <linux/netdevice.h>
 #include <linux/list.h>
+#include <net/dcbnl.h>
 
 #include "prestera.h"
 #include "prestera_hw.h"
@@ -86,6 +87,14 @@ enum prestera_cmd_type_t {
 	PRESTERA_CMD_TYPE_ROUTER_VR_ABORT = 0x632,
 	PRESTERA_CMD_TYPE_ROUTER_MP_HASH_SET = 0x650,
 
+	PRESTERA_CMD_TYPE_FLOOD_DOMAIN_CREATE = 0x700,
+	PRESTERA_CMD_TYPE_FLOOD_DOMAIN_DESTROY = 0x701,
+	PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_SET = 0x702,
+	PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_RESET = 0x703,
+
+	PRESTERA_CMD_TYPE_MDB_CREATE = 0x704,
+	PRESTERA_CMD_TYPE_MDB_DESTROY = 0x705,
+
 	PRESTERA_CMD_TYPE_RXTX_INIT = 0x800,
 
 	PRESTERA_CMD_TYPE_LAG_ADD = 0x900,
@@ -108,6 +117,10 @@ enum prestera_cmd_type_t {
 	PRESTERA_CMD_TYPE_NAT_NH_MANGLE_DEL = 0X1213,
 	PRESTERA_CMD_TYPE_NAT_NH_MANGLE_GET = 0X1214,
 
+	PRESTERA_CMD_TYPE_QOS_DSCP_PRIO_MAP_UPDATE = 0X1301,
+	PRESTERA_CMD_TYPE_QOS_TRUST_MODE_SET = 0X1302,
+	PRESTERA_CMD_TYPE_QOS_DEFAULT_PRIO_SET = 0X1303,
+
 	PRESTERA_CMD_TYPE_CPU_CODE_COUNTERS_GET = 0x2000,
 
 	PRESTERA_CMD_TYPE_ACK = 0x10000,
@@ -204,70 +217,72 @@ enum {
 };
 
 enum {
-	PRESTERA_HW_COUNTER_CLIENT_LOOKUP_0 = 0,
-	PRESTERA_HW_COUNTER_CLIENT_LOOKUP_1 = 1,
-	PRESTERA_HW_COUNTER_CLIENT_LOOKUP_2 = 2,
+	PRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_REG_PORT = 0,
+	PRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_LAG = 1,
+	PRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_MAX = 2,
 };
 
 struct prestera_msg_cmd {
-	u32 type;
-} __packed __aligned(4);
+	__le32 type;
+};
 
 struct prestera_msg_ret {
 	struct prestera_msg_cmd cmd;
-	u32 status;
-} __packed __aligned(4);
+	__le32 status;
+};
 
 struct prestera_msg_common_req {
 	struct prestera_msg_cmd cmd;
-} __packed __aligned(4);
+};
 
 struct prestera_msg_common_resp {
 	struct prestera_msg_ret ret;
-} __packed __aligned(4);
-
-union prestera_msg_switch_param {
-	u32 ageing_timeout;
-	u8  mac[ETH_ALEN];
-	u32 trap_policer_profile;
 };
 
 struct prestera_msg_switch_attr_req {
 	struct prestera_msg_cmd cmd;
-	u32 attr;
-	union prestera_msg_switch_param param;
-} __packed __aligned(4);
+	__le32 attr;
+	union {
+		__le32 ageing_timeout_ms;
+		__le32 trap_policer_profile;
+		struct {
+			u8 mac[ETH_ALEN];
+			u8 __pad[2];
+		};
+	} param;
+};
 
 struct prestera_msg_switch_init_resp {
 	struct prestera_msg_ret ret;
-	u32 port_count;
-	u32 mtu_max;
-	u8  switch_id;
-	u8  lag_max;
-	u8  lag_member_max;
-	u32 size_tbl_router_nexthop;
-} __packed __aligned(4);
+	__le32 port_count;
+	__le32 mtu_max;
+	__le32 size_tbl_router_nexthop;
+	u8 switch_id;
+	u8 lag_max;
+	u8 lag_member_max;
+};
 
 struct prestera_msg_event_port_param {
 	union {
 		struct {
+			__le32 mode;
+			__le32 speed;
 			u8 oper;
-			u32 mode;
-			u32 speed;
 			u8 duplex;
 			u8 fc;
 			u8 fec;
-		} mac;
+		} __packed mac; /* make sure always 12 bytes size */
 		struct {
+			__le64 lmode_bmap;
 			u8 mdix;
-			u64 lmode_bmap;
 			u8 fc;
-		} phy;
+			u8 __pad[2];
+		} __packed phy; /* make sure always 12 bytes size */
 	};
-} __packed __aligned(4);
+};
 
 struct prestera_msg_port_cap_param {
-	u64 link_mode;
+	__le64 link_mode;
 	u8  type;
 	u8  fec;
 	u8  fc;
@@ -277,301 +292,319 @@ struct prestera_msg_port_cap_param {
 struct prestera_msg_port_flood_param {
 	u8 type;
 	u8 enable;
+	u8 __pad[2];
 };
 
 union prestera_msg_port_param {
-	u8  oper_state;
-	u32 mtu;
-	u8  mac[ETH_ALEN];
-	u8  accept_frm_type;
-	u8  learning;
+	__le32 source_id_default;
+	__le32 source_id_filter;
+	__le32 mtu;
+	u8 oper_state;
+	u8 mac[ETH_ALEN];
+	u8 accept_frm_type;
+	u8 learning;
+	u8 type;
 	union {
 		struct {
-			/* TODO: merge it with "mode" */
-			u8 admin:1;
-			u8  fc;
+			u8 admin;
+			u8 fc;
 			u8 ap_enable;
+			u8 __reserved[5];
 			union {
 				struct {
-					u32 mode;
-					u8  inband:1;
-					u32 speed;
-					u8  duplex;
-					u8  fec;
-					u8  fec_supp;
+					__le32 mode;
+					__le32 speed;
+					u8 inband;
+					u8 duplex;
+					u8 fec;
+					u8 fec_supp;
 				} reg_mode;
 				struct {
-					u32 mode;
-					u32 speed;
-					u8  fec;
-					u8  fec_supp;
+					__le32 mode;
+					__le32 speed;
+					u8 fec;
+					u8 fec_supp;
+					u8 __pad[2];
 				} ap_modes[PRESTERA_AP_PORT_MAX];
 			};
 		} mac;
 		struct {
-			/* TODO: merge it with "mode" */
-			u8 admin:1;
+			__le64 modes;
+			__le32 mode;
+			u8 admin;
 			u8 adv_enable;
-			u64 modes;
-			/* TODO: merge it with modes */
-			u32 mode;
 			u8 mdix;
+			u8 __pad;
 		} phy;
 	} link;
-	u8  type;
+
 	struct prestera_msg_port_cap_param cap;
-	struct prestera_msg_port_flood_param flood;
-	u32 source_id_default;
-	u32 source_id_filter;
-	/* Used for return */
+	struct prestera_msg_port_flood_param flood_ext;
 	struct prestera_msg_event_port_param link_evt;
 };
 
 struct prestera_msg_port_attr_req {
 	struct prestera_msg_cmd cmd;
-	u32 attr;
-	u32 port;
-	u32 dev;
+	__le32 attr;
+	__le32 port;
+	__le32 dev;
 	union prestera_msg_port_param param;
-} __packed __aligned(4);
+};
 
 struct prestera_msg_port_attr_resp {
 	struct prestera_msg_ret ret;
 	union prestera_msg_port_param param;
-} __packed __aligned(4);
+};
 
 struct prestera_msg_port_stats_resp {
 	struct prestera_msg_ret ret;
-	u64 stats[PRESTERA_PORT_CNT_MAX];
-} __packed __aligned(4);
+	__le64 stats[PRESTERA_PORT_CNT_MAX];
+};
 
 struct prestera_msg_port_info_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-} __packed __aligned(4);
+	__le32 port;
+};
 
 struct prestera_msg_port_info_resp {
 	struct prestera_msg_ret ret;
-	u32 hw_id;
-	u32 dev_id;
-	u16 fp_id;
-} __packed __aligned(4);
+	__le32 hw_id;
+	__le32 dev_id;
+	__le16 fp_id;
+	u8 pad[2];
+};
 
 struct prestera_msg_port_storm_control_cfg_set_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-	u32 dev;
-	u32 storm_type;
-	u32 kbyte_per_sec_rate;
-} __packed __aligned(4);
+	__le32 port;
+	__le32 dev;
+	__le32 storm_type;
+	__le32 kbyte_per_sec_rate;
+};
 
 struct prestera_msg_vlan_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-	u32 dev;
-	u16 vid;
+	__le32 port;
+	__le32 dev;
+	__le16 vid;
 	u8  is_member;
 	u8  is_tagged;
-} __packed __aligned(4);
+};
 
 struct prestera_msg_fdb_req {
 	struct prestera_msg_cmd cmd;
-	u8 dest_type;
+	__le32 flush_mode;
 	union {
 		struct {
-			u32 port;
-			u32 dev;
+			__le32 port;
+			__le32 dev;
 		};
-		u16 lag_id;
+		__le16 lag_id;
 	} dest;
-	u8  mac[ETH_ALEN];
-	u16 vid;
-	u8  dynamic;
-	u32 flush_mode;
-} __packed __aligned(4);
+	__le16 vid;
+	u8 dest_type;
+	u8 dynamic;
+	u8 mac[ETH_ALEN];
+	u8 __pad[2];
+};
 
 struct prestera_msg_log_lvl_set_req {
 	struct prestera_msg_cmd cmd;
-	u32 lib;
-	u32 type;
-} __packed __aligned(4);
+	__le32 lib;
+	__le32 type;
+};
 
 struct prestera_msg_iface {
-	u8 type;
-	u16 vid;
-	u16 vr_id;
 	union {
 		struct {
-			u32 dev;
-			u32 port;
-		} __packed;
-		u16 lag_id;
+			__le32 dev;
+			__le32 port;
+		};
+		__le16 lag_id;
 	};
-} __packed;
+	__le16 vr_id;
+	__le16 vid;
+	u8 type;
+	u8 pad[3];
+};
 
 struct prestera_msg_ip_addr {
-	u8 v; /* e.g. PRESTERA_IPV4 */
 	union {
-		__be32 ipv4;
 		__be32 ipv6[4];
+		__be32 ipv4;
 	} u;
-} __packed;
+	u8 v; /* e.g. PRESTERA_IPV4 */
+	u8 pad[3];
+};
 
 struct prestera_msg_nh {
 	struct prestera_msg_iface oif;
-	u8 is_active;
-	u32 hw_id;
+	__le32 hw_id;
 	u8 mac[ETH_ALEN];
-} __packed;
+	u8 is_active;
+	u8 pad;
+};
 
 struct prestera_msg_nh_mangle_info {
-	u8 l4_src_valid:1, l4_dst_valid:1,
-	   sip_valid:1, dip_valid:1;
-	__be16 l4_src;
-	__be16 l4_dst;
+	struct prestera_msg_nh nh;
 	__be32 sip;
 	__be32 dip;
-	struct prestera_msg_nh nh;
-} __packed __aligned(4);
+	__be16 l4_src;
+	__be16 l4_dst;
+	u8 l4_src_valid:1;
+	u8 l4_dst_valid:1;
+	u8 sip_valid:1;
+	u8 dip_valid:1;
+	u8 pad[3];
+};
 
 struct prestera_msg_nh_mangle_req {
 	struct prestera_msg_cmd cmd;
-	u32 nh_id;
 	struct prestera_msg_nh_mangle_info info;
-} __packed __aligned(4);
+	__le32 nh_id;
+};
 
 struct prestera_msg_nh_mangle_resp {
 	struct prestera_msg_ret ret;
-	u32 nh_id;
 	struct prestera_msg_nh_mangle_info info;
-} __packed __aligned(4);
+	__le32 nh_id;
+};
 
 struct prestera_msg_acl_action {
-	u32 id;
+	__le32 id;
+	__le32 __reserved;
 	union {
 		struct {
 			u8 hw_tc;
-		} __packed trap;
+		} trap;
 		struct {
-			u64 rate;
-			u64 burst;
-		} __packed police;
+			__le64 rate;
+			__le64 burst;
+		} police;
 		struct {
-			u32 nh_id;
-		} __packed nh;
+			__le32 nh_id;
+		} nh;
 		struct {
 			__be32 old_addr;
 			__be32 new_addr;
-			u32 port;
-			u32 dev;
-			u32 flags;
-		} __packed nat;
+			__le32 port;
+			__le32 dev;
+			__le32 flags;
+			__le32 __pad;
+		} nat;
+		struct {
+			__le32 index;
+		} jump;
 		struct {
-			u32 index;
-		} __packed jump;
+			__le32 id;
+		} count;
 		struct {
-			u32 id;
-		} __packed count;
+			u32 dscp;
+		} remark;
 	};
-} __packed __aligned(4);
+};
 
 struct prestera_msg_vtcam_create_req {
 	struct prestera_msg_cmd cmd;
-	u32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
+	__le32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
+	u8 direction;
 	u8 lookup;
-	u32 direction;
-} __packed __aligned(4);
+	u8 pad[2];
+};
 
 struct prestera_msg_vtcam_destroy_req {
 	struct prestera_msg_cmd cmd;
-	u32 vtcam_id;
-} __packed __aligned(4);
+	__le32 vtcam_id;
+};
 
 struct prestera_msg_vtcam_rule_add_req {
 	struct prestera_msg_cmd cmd;
-	u32 key[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
-	u32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
-	u32 vtcam_id;
-	u32 prio;
-	u8 n_act;
-} __packed __aligned(4);
+	__le32 key[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
+	__le32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];
+	__le32 vtcam_id;
+	__le32 prio;
+	__le32 n_act;
+};
 
 struct prestera_msg_vtcam_rule_del_req {
 	struct prestera_msg_cmd cmd;
-	u32 vtcam_id;
-	u32 id;
-} __packed __aligned(4);
+	__le32 vtcam_id;
+	__le32 id;
+};
 
 struct prestera_msg_vtcam_bind_req {
 	struct prestera_msg_cmd cmd;
 	union {
 		struct {
-			u32 hw_id;
-			u32 dev_id;
-		} __packed port;
-		u32 index;
-	};
-	u32 vtcam_id;
-	u16 pcl_id;
-	u8 type;
-} __packed __aligned(4);
+			__le32 hw_id;
+			__le32 dev_id;
+		} port;
+		__le32 index;
+	};
+	__le32 vtcam_id;
+	__le16 pcl_id;
+	__le16 type;
+};
 
 struct prestera_msg_vtcam_resp {
 	struct prestera_msg_ret ret;
-	u32 vtcam_id;
-	u32 rule_id;
-} __packed __aligned(4);
+	__le32 vtcam_id;
+	__le32 rule_id;
+};
 
 struct prestera_msg_counter_req {
 	struct prestera_msg_cmd cmd;
-	u32 client;
-	u32 block_id;
-	u32 num_counters;
-} __packed __aligned(4);
+	__le32 client;
+	__le32 block_id;
+	__le32 num_counters;
+};
 
 struct prestera_msg_counter_stats {
-	u64 packets;
-	u64 bytes;
-} __packed;
+	__le64 packets;
+	__le64 bytes;
+};
 
 struct prestera_msg_counter_resp {
 	struct prestera_msg_ret ret;
-	u32 block_id;
-	u32 offset;
-	u32 num_counters;
-	u32 done;
+	__le32 block_id;
+	__le32 offset;
+	__le32 num_counters;
+	__le32 done;
 	struct prestera_msg_counter_stats stats[0];
-} __packed __aligned(4);
+};
 
 struct prestera_msg_nat_port_req {
 	struct prestera_msg_cmd cmd;
+	__le32 port;
+	__le32 dev;
 	u8 neigh_mac[ETH_ALEN];
-	u32 port;
-	u32 dev;
-} __packed __aligned(4);
+	u8 __pad[2];
+};
 
 struct prestera_msg_span_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-	u32 dev;
+	__le32 port;
+	__le32 dev;
 	u8 id;
-} __packed __aligned(4);
+	u8 pad[3];
+};
 
 struct prestera_msg_span_resp {
 	struct prestera_msg_ret ret;
 	u8 id;
-} __packed __aligned(4);
+	u8 pad[3];
+};
 
 struct prestera_msg_event {
-	u16 type;
-	u16 id;
-} __packed __aligned(4);
+	__le16 type;
+	__le16 id;
+};
 
 struct prestera_msg_event_log {
 	struct prestera_msg_event id;
-	u32 log_string_size;
+	__le32 log_string_size;
 	u8 log_string[0];
-} __packed __aligned(4);
+};
 
 union prestera_msg_event_fdb_param {
 	u8 mac[ETH_ALEN];
@@ -579,150 +612,297 @@ union prestera_msg_event_fdb_param {
 
 struct prestera_msg_event_fdb {
 	struct prestera_msg_event id;
-	u8 dest_type;
+	__le32 vid;
 	union {
-		u32 port_id;
-		u16 lag_id;
+		__le32 port_id;
+		__le16 lag_id;
 	} dest;
-	u32 vid;
 	union prestera_msg_event_fdb_param param;
-} __packed __aligned(4);
+	u8 dest_type;
+};
 
 struct prestera_msg_event_port {
 	struct prestera_msg_event id;
-	u32 port_id;
+	__le32 port_id;
 	struct prestera_msg_event_port_param param;
-} __packed __aligned(4);
+};
 
 struct prestera_msg_bridge_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-	u32 dev;
-	u16 bridge;
-} __packed __aligned(4);
+	__le32 port;
+	__le32 dev;
+	__le16 bridge;
+	u8 pad[2];
+};
 
 struct prestera_msg_bridge_resp {
 	struct prestera_msg_ret ret;
-	u16 bridge;
-} __packed __aligned(4);
+	__le16 bridge;
+	u8 pad[2];
+};
 
 struct prestera_msg_macvlan_req {
 	struct prestera_msg_cmd cmd;
-	u16 vr_id;
+	__le16 vr_id;
+	__le16 vid;
 	u8 mac[ETH_ALEN];
-	u16 vid;
-} __packed __aligned(4);
+	u8 pad[2];
+};
 
 struct prestera_msg_stp_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-	u32 dev;
-	u16 vid;
+	__le32 port;
+	__le32 dev;
+	__le16 vid;
 	u8  state;
-} __packed __aligned(4);
+	u8 __pad;
+};
 
 struct prestera_msg_rif_req {
 	struct prestera_msg_cmd cmd;
 	struct prestera_msg_iface iif;
-	u16 rif_id;
+	__le32 mtu;
+	__le16 rif_id;
+	__le16 __reserved;
 	u8 mac[ETH_ALEN];
-	u32 mtu;
-} __packed __aligned(4);
+	u8 __pad[2];
+};
 
 struct prestera_msg_rif_resp {
 	struct prestera_msg_ret ret;
-	u16 rif_id;
-} __packed __aligned(4);
+	__le16 rif_id;
+	__le16 __pad;
+};
 
 struct prestera_msg_lpm_req {
 	struct prestera_msg_cmd cmd;
-	u32 grp_id;
 	struct prestera_msg_ip_addr dst;
-	u32 dst_len;
-	u16 vr_id;
-} __packed __aligned(4);
+	__le32 grp_id;
+	__le32 dst_len;
+	__le16 vr_id;
+	__le16 __pad;
+};
 
 struct prestera_msg_nh_req {
 	struct prestera_msg_cmd cmd;
-	u32 size;
-	u32 grp_id;
 	struct prestera_msg_nh nh[PRESTERA_NHGR_SIZE_MAX];
-} __packed __aligned(4);
+	__le32 size;
+	__le32 grp_id;
+};
 
 struct prestera_msg_nh_resp {
 	struct prestera_msg_ret ret;
 	struct prestera_msg_nh nh[PRESTERA_NHGR_SIZE_MAX];
-} __packed __aligned(4);
+};
 
 struct prestera_msg_nh_chunk_req {
 	struct prestera_msg_cmd cmd;
-	u32 offset;
-} __packed __aligned(4);
+	__le32 offset;
+};
 
 struct prestera_msg_nh_chunk_resp {
 	struct prestera_msg_ret ret;
 	u8 hw_state[PRESTERA_MSG_CHUNK_SIZE];
-} __packed __aligned(4);
+};
 
 struct prestera_msg_nh_grp_req {
 	struct prestera_msg_cmd cmd;
-	u32 grp_id;
-	u32 size;
-} __packed __aligned(4);
+	__le32 grp_id;
+	__le32 size;
+};
 
 struct prestera_msg_nh_grp_resp {
 	struct prestera_msg_ret ret;
-	u32 grp_id;
-} __packed __aligned(4);
+	__le32 grp_id;
+};
 
 struct prestera_msg_mp_req {
 	struct prestera_msg_cmd cmd;
 	u8 hash_policy;
-} __packed __aligned(4);
+	u8 __pad[3];
+};
 
 struct prestera_msg_rxtx_req {
 	struct prestera_msg_cmd cmd;
 	u8 use_sdma;
-} __packed __aligned(4);
+	u8 pad[3];
+};
 
 struct prestera_msg_rxtx_resp {
 	struct prestera_msg_ret ret;
-	u32 map_addr;
-} __packed __aligned(4);
+	__le32 map_addr;
+};
 
 struct prestera_msg_vr_req {
 	struct prestera_msg_cmd cmd;
-	u16 vr_id;
-} __packed __aligned(4);
+	__le16 vr_id;
+	__le16 __pad;
+};
 
 struct prestera_msg_vr_resp {
 	struct prestera_msg_ret ret;
-	u16 vr_id;
-} __packed __aligned(4);
+	__le16 vr_id;
+	__le16 __pad;
+};
 
 struct prestera_msg_lag_req {
 	struct prestera_msg_cmd cmd;
-	u32 port;
-	u32 dev;
-	u16 lag_id;
-	u16 vr_id;
-} __packed __aligned(4);
+	__le32 port;
+	__le32 dev;
+	__le16 lag_id;
+	__le16 vr_id;
+};
 
 struct prestera_msg_keepalive_init_req {
 	struct prestera_msg_cmd cmd;
-	u32 pulse_timeout_ms;
-} __packed __aligned(4);
+	__le32 pulse_timeout_ms;
+};
 
 struct prestera_msg_cpu_code_counter_req {
 	struct prestera_msg_cmd cmd;
 	u8 counter_type;
 	u8 code;
-} __packed __aligned(4);
+	u8 pad[2];
+};
 
 struct prestera_msg_cpu_code_counter_resp {
 	struct prestera_msg_ret ret;
-	u64 packet_count;
-} __packed __aligned(4);
+	__le64 packet_count;
+};
+
+struct prestera_msg_flood_domain_create_req {
+	struct prestera_msg_cmd cmd;
+};
+
+struct prestera_msg_flood_domain_create_resp {
+	struct prestera_msg_ret ret;
+	__le32 flood_domain_idx;
+};
+
+struct prestera_msg_flood_domain_destroy_req {
+	struct prestera_msg_cmd cmd;
+	__le32 flood_domain_idx;
+};
+
+struct prestera_msg_flood_domain_ports_set_req {
+	struct prestera_msg_cmd cmd;
+	__le32 flood_domain_idx;
+	__le32 ports_num;
+};
+
+struct prestera_msg_flood_domain_ports_reset_req {
+	struct prestera_msg_cmd cmd;
+	__le32 flood_domain_idx;
+};
+
+struct prestera_msg_flood_domain_port {
+	union {
+		struct {
+			__le32 port_num;
+			__le32 dev_num;
+		};
+		__le16 lag_id;
+	};
+	__le16 vid;
+	__le16 port_type;
+};
+
+struct prestera_msg_mdb_create_req {
+	struct prestera_msg_cmd cmd;
+	__le32 flood_domain_idx;
+	__le16 vid;
+	u8 mac[ETH_ALEN];
+};
+
+struct prestera_msg_mdb_destroy_req {
+	struct prestera_msg_cmd cmd;
+	__le32 flood_domain_idx;
+	__le16 vid;
+	u8 mac[ETH_ALEN];
+};
+
+struct prestera_msg_qos_req {
+	struct prestera_msg_cmd cmd;
+	u32 port;
+	u32 dev;
+	u32 priority;
+	u32 mode;
+	u8  dscp[64];
+};
+
+static void prestera_hw_build_tests(void)
+{
+	/* check requests */
+	BUILD_BUG_ON(sizeof(struct prestera_msg_common_req) != 4);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_switch_attr_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_port_attr_req) != 144);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_port_info_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vlan_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_fdb_req) != 28);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_bridge_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_span_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_stp_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_rxtx_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_lag_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_cpu_code_counter_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_create_req) != 88);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_destroy_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_add_req) != 176);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_del_req) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_bind_req) != 20);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_counter_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_counter_stats) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_mangle_req) != 52);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nat_port_req) != 20);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_macvlan_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_rif_req) != 36);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_lpm_req) != 36);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_req) != 124);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_chunk_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_grp_req) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_mp_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vr_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_keepalive_init_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_create_req) != 4);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_destroy_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_ports_set_req) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_ports_reset_req) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_mdb_create_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_mdb_destroy_req) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_qos_req) != 84);
+
+	/* structure that are part of req/resp fw messages */
+	BUILD_BUG_ON(sizeof(struct prestera_msg_acl_action) != 32);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_iface) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_ip_addr) != 20);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh) != 28);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_mangle_info) != 44);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_port) != 12);
+
+	/* check responses */
+	BUILD_BUG_ON(sizeof(struct prestera_msg_common_resp) != 8);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_switch_init_resp) != 24);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_port_attr_resp) != 136);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_port_stats_resp) != 248);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_port_info_resp) != 20);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_bridge_resp) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_span_resp) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_rxtx_resp) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_resp) != 16);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_counter_resp) != 24);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_mangle_resp) != 56);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_rif_resp) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_resp) != 120);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_chunk_resp) != 1032);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_nh_grp_resp) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vr_resp) != 12);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_create_resp) != 12);
+
+	/* check events */
+	BUILD_BUG_ON(sizeof(struct prestera_msg_event_port) != 20);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_event_fdb) != 20);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_event_log) != 8);
+}
 
 static void fw_reset_wdog(struct prestera_device *dev);
 
@@ -741,15 +921,15 @@ static int prestera_cmd_qid_by_req_type(enum prestera_cmd_type_t type)
 	}
 }
 
-#define fw_check_resp(_response)	\
-({								\
-	int __er = 0;						\
-	typeof(_response) __r = (_response);			\
-	if (__r->ret.cmd.type != PRESTERA_CMD_TYPE_ACK)		\
-		__er = -EBADE;					\
-	else if (__r->ret.status != PRESTERA_CMD_ACK_OK)		\
-		__er = -EINVAL;					\
-	(__er);							\
+#define fw_check_resp(_response)							\
+({											\
+	int __er = 0;									\
+	typeof(_response) __r = (_response);						\
+	if (__r->ret.cmd.type != __cpu_to_le32((u32)PRESTERA_CMD_TYPE_ACK))		\
+		__er = -EBADE;								\
+	else if (__r->ret.status != __cpu_to_le32((u32)PRESTERA_CMD_ACK_OK))		\
+		__er = -EINVAL;								\
+	(__er);										\
 })
 
 #define __fw_send_req_resp(_switch, _type, _request, _req_size,	\
@@ -760,9 +940,9 @@ _response, _resp_size, _wait)					\
 	typeof(_request) __req = (_request);			\
 	typeof(_response) __resp = (_response);			\
 	typeof(_type) __type = (_type);				\
-	__req->cmd.type = (__type);				\
+	__req->cmd.type = __cpu_to_le32(__type);			\
 	__e = __sw->dev->send_req(__sw->dev,			\
-		prestera_cmd_qid_by_req_type(__type),		\
+	prestera_cmd_qid_by_req_type(__type),			\
 		(u8 *)__req, _req_size,				\
 		(u8 *)__resp, _resp_size,			\
 		_wait);						\
@@ -850,12 +1030,12 @@ static int fw_parse_port_evt(u8 *msg, struct prestera_event *evt)
 
 	hw_evt = (struct prestera_msg_event_port *)msg;
 
-	evt->port_evt.port_id = hw_evt->port_id;
+	evt->port_evt.port_id = __le32_to_cpu(hw_evt->port_id);
 
 	if (evt->id == PRESTERA_PORT_EVENT_MAC_STATE_CHANGED) {
 		evt->port_evt.data.mac.oper = hw_evt->param.mac.oper;
-		evt->port_evt.data.mac.mode = hw_evt->param.mac.mode;
-		evt->port_evt.data.mac.speed = hw_evt->param.mac.speed;
+		evt->port_evt.data.mac.mode = __le32_to_cpu(hw_evt->param.mac.mode);
+		evt->port_evt.data.mac.speed = __le32_to_cpu(hw_evt->param.mac.speed);
 		evt->port_evt.data.mac.duplex = hw_evt->param.mac.duplex;
 		evt->port_evt.data.mac.fc = hw_evt->param.mac.fc;
 		evt->port_evt.data.mac.fec = hw_evt->param.mac.fec;
@@ -875,17 +1055,17 @@ static int fw_parse_fdb_evt(u8 *msg, struct prestera_event *evt)
 	switch (hw_evt->dest_type) {
 	case PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT:
 		evt->fdb_evt.type = PRESTERA_FDB_ENTRY_TYPE_REG_PORT;
-		evt->fdb_evt.dest.port_id = hw_evt->dest.port_id;
+		evt->fdb_evt.dest.port_id = __le32_to_cpu(hw_evt->dest.port_id);
 		break;
 	case PRESTERA_HW_FDB_ENTRY_TYPE_LAG:
 		evt->fdb_evt.type = PRESTERA_FDB_ENTRY_TYPE_LAG;
-		evt->fdb_evt.dest.lag_id = hw_evt->dest.lag_id;
+		evt->fdb_evt.dest.lag_id = __le16_to_cpu(hw_evt->dest.lag_id);
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	evt->fdb_evt.vid = hw_evt->vid;
+	evt->fdb_evt.vid = __le32_to_cpu(hw_evt->vid);
 
 	memcpy(&evt->fdb_evt.data, &hw_evt->param, sizeof(u8) * ETH_ALEN);
 
@@ -898,7 +1078,7 @@ static int fw_parse_log_evt(u8 *msg, struct prestera_event *evt)
 
 	hw_evt = (struct prestera_msg_event_log *)msg;
 
-	evt->fw_log_evt.log_len	= hw_evt->log_string_size;
+	evt->fw_log_evt.log_len	= __le32_to_cpu(hw_evt->log_string_size);
 	evt->fw_log_evt.data	= hw_evt->log_string;
 
 	return 0;
@@ -958,21 +1138,24 @@ static int fw_event_recv(struct prestera_device *dev, u8 *buf, size_t size)
 	struct prestera_switch *sw = dev->priv;
 	struct prestera_fw_event_handler eh;
 	struct prestera_event evt;
+	u16 msg_type;
 	int err;
 
 	fw_reset_wdog(dev);
-
-	if (msg->type >= PRESTERA_EVENT_TYPE_MAX)
+	msg_type = __le16_to_cpu(msg->type);
+	if (msg_type >= PRESTERA_EVENT_TYPE_MAX)
 		return -EINVAL;
+	if (!fw_event_parsers[msg_type].func)
+		return -ENOENT;
 
-	err = prestera_find_event_handler(sw, msg->type, &eh);
+	err = prestera_find_event_handler(sw, msg_type, &eh);
 
-	if (err || !fw_event_parsers[msg->type].func)
+	if (err || !fw_event_parsers[msg_type].func)
 		return 0;
 
-	evt.id = msg->id;
+	evt.id = __le16_to_cpu(msg->id);
 
-	err = fw_event_parsers[msg->type].func(buf, &evt);
+	err = fw_event_parsers[msg_type].func(buf, &evt);
 	if (!err)
 		eh.func(sw, &evt, eh.arg);
 
@@ -1000,18 +1183,19 @@ int prestera_hw_port_info_get(const struct prestera_port *port,
 {
 	struct prestera_msg_port_info_resp resp;
 	struct prestera_msg_port_info_req req = {
-		.port = port->id
+		.port = __cpu_to_le32(port->id)
 	};
 	int err;
 
 	err = fw_send_req_resp(port->sw, PRESTERA_CMD_TYPE_PORT_INFO_GET,
-			       &req, &resp);
+			&req, &resp);
+
 	if (err)
 		return err;
 
-	*hw_id = resp.hw_id;
-	*dev_id = resp.dev_id;
-	*fp_id = resp.fp_id;
+	*hw_id = __le32_to_cpu(resp.hw_id);
+	*dev_id = __le32_to_cpu(resp.dev_id);
+	*fp_id = __le16_to_cpu(resp.fp_id);
 
 	return 0;
 }
@@ -1019,7 +1203,7 @@ int prestera_hw_port_info_get(const struct prestera_port *port,
 int prestera_hw_switch_init(struct prestera_switch *sw)
 {
 	struct prestera_msg_keepalive_init_req keepalive_init_req = {
-		.pulse_timeout_ms = PRESTERA_FW_WD_KICK_TIMEOUT
+		.pulse_timeout_ms = __cpu_to_le32(PRESTERA_FW_WD_KICK_TIMEOUT)
 	};
 	struct prestera_msg_switch_init_resp resp;
 	struct prestera_msg_common_req req;
@@ -1027,18 +1211,20 @@ int prestera_hw_switch_init(struct prestera_switch *sw)
 
 	INIT_LIST_HEAD(&sw->event_handlers);
 
+	prestera_hw_build_tests();
+
 	err = fw_send_req_resp_wait(sw, PRESTERA_CMD_TYPE_SWITCH_INIT,
 				    &req, &resp, PRESTERA_HW_INIT_TIMEOUT);
 	if (err)
 		return err;
 
 	sw->id = resp.switch_id;
-	sw->port_count = resp.port_count;
+	sw->port_count = __le32_to_cpu(resp.port_count);
 	sw->mtu_min = PRESTERA_HW_MIN_MTU;
-	sw->mtu_max = resp.mtu_max;
+	sw->mtu_max = __le32_to_cpu(resp.mtu_max);
 	sw->lag_max = resp.lag_max;
 	sw->lag_member_max = resp.lag_member_max;
-	sw->size_tbl_router_nexthop = resp.size_tbl_router_nexthop;
+	sw->size_tbl_router_nexthop = __le32_to_cpu(resp.size_tbl_router_nexthop);
 	sw->dev->recv_msg = fw_event_recv;
 	sw->dev->recv_pkt = fw_pkt_recv;
 
@@ -1065,8 +1251,8 @@ int prestera_hw_switch_ageing_set(const struct prestera_switch *sw,
 				  u32 ageing_time)
 {
 	struct prestera_msg_switch_attr_req req = {
-		.param = {.ageing_timeout = ageing_time},
-		.attr = PRESTERA_CMD_SWITCH_ATTR_AGEING,
+		.param = {.ageing_timeout_ms = __cpu_to_le32(ageing_time)},
+		.attr = __cpu_to_le32(PRESTERA_CMD_SWITCH_ATTR_AGEING),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_SWITCH_ATTR_SET, &req);
@@ -1075,7 +1261,7 @@ int prestera_hw_switch_ageing_set(const struct prestera_switch *sw,
 int prestera_hw_switch_mac_set(const struct prestera_switch *sw, const u8 *mac)
 {
 	struct prestera_msg_switch_attr_req req = {
-		.attr = PRESTERA_CMD_SWITCH_ATTR_MAC,
+		.attr = __cpu_to_le32(PRESTERA_CMD_SWITCH_ATTR_MAC),
 	};
 
 	memcpy(req.param.mac, mac, sizeof(req.param.mac));
@@ -1087,8 +1273,8 @@ int prestera_hw_switch_trap_policer_set(const struct prestera_switch *sw,
 					u8 profile)
 {
 	struct prestera_msg_switch_attr_req req = {
-		.param = {.trap_policer_profile = profile},
-		.attr = PRESTERA_CMD_SWITCH_ATTR_TRAP_POLICER,
+		.param = {.trap_policer_profile = __cpu_to_le32(profile)},
+		.attr = __cpu_to_le32(PRESTERA_CMD_SWITCH_ATTR_TRAP_POLICER),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_SWITCH_ATTR_SET, &req);
@@ -1097,10 +1283,10 @@ int prestera_hw_switch_trap_policer_set(const struct prestera_switch *sw,
 int prestera_hw_port_mtu_set(const struct prestera_port *port, u32 mtu)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_MTU,
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.param = {.mtu = mtu}
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MTU),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.param = {.mtu = __cpu_to_le32(mtu)}
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET, &req);
@@ -1110,9 +1296,9 @@ int prestera_hw_port_mtu_get(const struct prestera_port *port, u32 *mtu)
 {
 	struct prestera_msg_port_attr_resp resp;
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_MTU,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MTU),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 	int err;
 
@@ -1121,7 +1307,7 @@ int prestera_hw_port_mtu_get(const struct prestera_port *port, u32 *mtu)
 	if (err)
 		return err;
 
-	*mtu = resp.param.mtu;
+	*mtu = __le32_to_cpu(resp.param.mtu);
 
 	return err;
 }
@@ -1129,9 +1315,9 @@ int prestera_hw_port_mtu_get(const struct prestera_port *port, u32 *mtu)
 int prestera_hw_port_mac_set(const struct prestera_port *port, char *mac)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_MAC,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 	memcpy(&req.param.mac, mac, sizeof(req.param.mac));
 
@@ -1142,9 +1328,9 @@ int prestera_hw_port_mac_get(const struct prestera_port *port, char *mac)
 {
 	struct prestera_msg_port_attr_resp resp;
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_MAC,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 	int err;
 
@@ -1162,9 +1348,9 @@ int prestera_hw_port_accept_frame_type_set(const struct prestera_port *port,
 					   enum prestera_accept_frame_type type)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_ACCEPT_FRAME_TYPE,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_ACCEPT_FRAME_TYPE),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {.accept_frm_type = type}
 	};
 
@@ -1174,9 +1360,9 @@ int prestera_hw_port_accept_frame_type_set(const struct prestera_port *port,
 int prestera_hw_port_learning_set(const struct prestera_port *port, bool enable)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_LEARNING,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_LEARNING),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {.learning = enable ? 1 : 0}
 	};
 
@@ -1227,7 +1413,7 @@ void prestera_hw_event_handler_unregister(struct prestera_switch *sw,
 int prestera_hw_vlan_create(const struct prestera_switch *sw, u16 vid)
 {
 	struct prestera_msg_vlan_req req = {
-		.vid = vid,
+		.vid = __cpu_to_le16(vid),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_VLAN_CREATE, &req);
@@ -1236,7 +1422,7 @@ int prestera_hw_vlan_create(const struct prestera_switch *sw, u16 vid)
 int prestera_hw_vlan_delete(const struct prestera_switch *sw, u16 vid)
 {
 	struct prestera_msg_vlan_req req = {
-		.vid = vid,
+		.vid = __cpu_to_le16(vid),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_VLAN_DELETE, &req);
@@ -1246,9 +1432,9 @@ int prestera_hw_vlan_port_set(const struct prestera_port *port,
 			      u16 vid, bool is_member, bool untagged)
 {
 	struct prestera_msg_vlan_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.vid = vid,
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.vid = __cpu_to_le16(vid),
 		.is_member = is_member ? 1 : 0,
 		.is_tagged = untagged ? 0 : 1
 	};
@@ -1259,9 +1445,9 @@ int prestera_hw_vlan_port_set(const struct prestera_port *port,
 int prestera_hw_vlan_port_vid_set(const struct prestera_port *port, u16 vid)
 {
 	struct prestera_msg_vlan_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.vid = vid
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.vid = __cpu_to_le16(vid)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_VLAN_PVID_SET, &req);
@@ -1270,9 +1456,9 @@ int prestera_hw_vlan_port_vid_set(const struct prestera_port *port, u16 vid)
 int prestera_hw_port_vid_stp_set(struct prestera_port *port, u16 vid, u8 state)
 {
 	struct prestera_msg_stp_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.vid = vid,
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.vid = __cpu_to_le16(vid),
 		.state = state
 	};
 
@@ -1282,13 +1468,13 @@ int prestera_hw_port_vid_stp_set(struct prestera_port *port, u16 vid, u8 state)
 int prestera_hw_port_uc_flood_set(const struct prestera_port *port, bool flood)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_FLOOD,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_FLOOD),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {
-			.flood = {
+			.flood_ext = {
 				.type = PRESTERA_PORT_FLOOD_TYPE_UC,
-				.enable = flood ? 1 : 0,
+				.enable = flood,
 			}
 		}
 	};
@@ -1299,13 +1485,13 @@ int prestera_hw_port_uc_flood_set(const struct prestera_port *port, bool flood)
 int prestera_hw_port_mc_flood_set(const struct prestera_port *port, bool flood)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_FLOOD,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_FLOOD),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {
-			.flood = {
+			.flood_ext = {
 				.type = PRESTERA_PORT_FLOOD_TYPE_MC,
-				.enable = flood ? 1 : 0,
+				.enable = flood,
 			}
 		}
 	};
@@ -1317,11 +1503,11 @@ int prestera_hw_port_srcid_default_set(const struct prestera_port *port,
 				       u32 sourceid)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_SOURCE_ID_DEFAULT,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_SOURCE_ID_DEFAULT),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {
-			.source_id_default = sourceid
+			.source_id_default = __cpu_to_le32(sourceid)
 		}
 	};
 
@@ -1332,11 +1518,11 @@ int prestera_hw_port_srcid_filter_set(const struct prestera_port *port,
 				      u32 sourceid)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_SOURCE_ID_FILTER,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_SOURCE_ID_FILTER),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {
-			.source_id_filter = sourceid
+			.source_id_filter = __cpu_to_le32(sourceid)
 		}
 	};
 
@@ -1349,11 +1535,11 @@ int prestera_hw_fdb_add(const struct prestera_port *port,
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT,
 		.dest = {
-			.dev = port->dev_id,
-			.port = port->hw_id,
+			.dev = __cpu_to_le32(port->dev_id),
+			.port = __cpu_to_le32(port->hw_id),
 		},
-		.vid = vid,
-		.dynamic = dynamic ? 1 : 0
+		.vid = __cpu_to_le16(vid),
+		.dynamic = dynamic
 	};
 
 	memcpy(req.mac, mac, sizeof(req.mac));
@@ -1366,8 +1552,8 @@ int prestera_hw_lag_fdb_add(const struct prestera_switch *sw, u16 lag_id,
 {
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,
-		.dest = { .lag_id = lag_id },
-		.vid = vid,
+		.dest = { .lag_id = __cpu_to_le16(lag_id) },
+		.vid = __cpu_to_le16(vid),
 		.dynamic = dynamic
 	};
 
@@ -1382,10 +1568,10 @@ int prestera_hw_fdb_del(const struct prestera_port *port,
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT,
 		.dest = {
-			.dev = port->dev_id,
-			.port = port->hw_id,
+			.dev = __cpu_to_le32(port->dev_id),
+			.port = __cpu_to_le32(port->hw_id),
 		},
-		.vid = vid
+		.vid = __cpu_to_le16(vid)
 	};
 
 	memcpy(req.mac, mac, sizeof(req.mac));
@@ -1398,8 +1584,8 @@ int prestera_hw_lag_fdb_del(const struct prestera_switch *sw, u16 lag_id,
 {
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,
-		.dest = { .lag_id = lag_id },
-		.vid = vid
+		.dest = { .lag_id = __cpu_to_le16(lag_id) },
+		.vid = __cpu_to_le16(vid)
 	};
 
 	memcpy(req.mac, mac, sizeof(req.mac));
@@ -1412,9 +1598,9 @@ int prestera_hw_port_cap_get(const struct prestera_port *port,
 {
 	struct prestera_msg_port_attr_resp resp;
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_CAPABILITY,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_CAPABILITY),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 	int err;
 
@@ -1423,7 +1609,7 @@ int prestera_hw_port_cap_get(const struct prestera_port *port,
 	if (err)
 		return err;
 
-	caps->supp_link_modes = resp.param.cap.link_mode;
+	caps->supp_link_modes = __le64_to_cpu(resp.param.cap.link_mode);
 	caps->supp_fec = resp.param.cap.fec;
 	caps->type = resp.param.cap.type;
 	caps->transceiver = resp.param.cap.transceiver;
@@ -1484,8 +1670,8 @@ int prestera_hw_fw_log_level_set(const struct prestera_switch *sw,
 				 u32 lib, u32 type)
 {
 	struct prestera_msg_log_lvl_set_req req = {
-		.lib = lib,
-		.type = type
+		.lib = __cpu_to_le32(lib),
+		.type = __cpu_to_le32(type)
 	};
 	int err;
 
@@ -1501,59 +1687,59 @@ int prestera_hw_port_stats_get(const struct prestera_port *port,
 {
 	struct prestera_msg_port_stats_resp resp;
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_STATS,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_STATS),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
-	u64 *hw_val = resp.stats;
 	int err;
+	__le64 *hw_val = resp.stats;
 
 	err = fw_send_req_resp(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,
 			       &req, &resp);
 	if (err)
 		return err;
 
-	stats->good_octets_received = hw_val[PRESTERA_PORT_GOOD_OCTETS_RCV_CNT];
-	stats->bad_octets_received = hw_val[PRESTERA_PORT_BAD_OCTETS_RCV_CNT];
-	stats->mac_trans_error = hw_val[PRESTERA_PORT_MAC_TRANSMIT_ERR_CNT];
+	stats->good_octets_received = __le64_to_cpu(hw_val[PRESTERA_PORT_GOOD_OCTETS_RCV_CNT]);
+	stats->bad_octets_received = __le64_to_cpu(hw_val[PRESTERA_PORT_BAD_OCTETS_RCV_CNT]);
+	stats->mac_trans_error = __le64_to_cpu(hw_val[PRESTERA_PORT_MAC_TRANSMIT_ERR_CNT]);
 	stats->broadcast_frames_received =
-		hw_val[PRESTERA_PORT_BRDC_PKTS_RCV_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_BRDC_PKTS_RCV_CNT]);
 	stats->multicast_frames_received =
-		hw_val[PRESTERA_PORT_MC_PKTS_RCV_CNT];
-	stats->frames_64_octets = hw_val[PRESTERA_PORT_PKTS_64_OCTETS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_MC_PKTS_RCV_CNT]);
+	stats->frames_64_octets = __le64_to_cpu(hw_val[PRESTERA_PORT_PKTS_64_OCTETS_CNT]);
 	stats->frames_65_to_127_octets =
-		hw_val[PRESTERA_PORT_PKTS_65TO127_OCTETS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_PKTS_65TO127_OCTETS_CNT]);
 	stats->frames_128_to_255_octets =
-		hw_val[PRESTERA_PORT_PKTS_128TO255_OCTETS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_PKTS_128TO255_OCTETS_CNT]);
 	stats->frames_256_to_511_octets =
-		hw_val[PRESTERA_PORT_PKTS_256TO511_OCTETS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_PKTS_256TO511_OCTETS_CNT]);
 	stats->frames_512_to_1023_octets =
-		hw_val[PRESTERA_PORT_PKTS_512TO1023_OCTETS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_PKTS_512TO1023_OCTETS_CNT]);
 	stats->frames_1024_to_max_octets =
-		hw_val[PRESTERA_PORT_PKTS_1024TOMAX_OCTETS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_PKTS_1024TOMAX_OCTETS_CNT]);
 	stats->excessive_collision =
-		hw_val[PRESTERA_PORT_EXCESSIVE_COLLISIONS_CNT];
-	stats->multicast_frames_sent = hw_val[PRESTERA_PORT_MC_PKTS_SENT_CNT];
-	stats->broadcast_frames_sent = hw_val[PRESTERA_PORT_BRDC_PKTS_SENT_CNT];
-	stats->fc_sent = hw_val[PRESTERA_PORT_FC_SENT_CNT];
-	stats->fc_received = hw_val[PRESTERA_PORT_GOOD_FC_RCV_CNT];
-	stats->buffer_overrun = hw_val[PRESTERA_PORT_DROP_EVENTS_CNT];
-	stats->undersize = hw_val[PRESTERA_PORT_UNDERSIZE_PKTS_CNT];
-	stats->fragments = hw_val[PRESTERA_PORT_FRAGMENTS_PKTS_CNT];
-	stats->oversize = hw_val[PRESTERA_PORT_OVERSIZE_PKTS_CNT];
-	stats->jabber = hw_val[PRESTERA_PORT_JABBER_PKTS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_EXCESSIVE_COLLISIONS_CNT]);
+	stats->multicast_frames_sent = __le64_to_cpu(hw_val[PRESTERA_PORT_MC_PKTS_SENT_CNT]);
+	stats->broadcast_frames_sent = __le64_to_cpu(hw_val[PRESTERA_PORT_BRDC_PKTS_SENT_CNT]);
+	stats->fc_sent = __le64_to_cpu(hw_val[PRESTERA_PORT_FC_SENT_CNT]);
+	stats->fc_received = __le64_to_cpu(hw_val[PRESTERA_PORT_GOOD_FC_RCV_CNT]);
+	stats->buffer_overrun = __le64_to_cpu(hw_val[PRESTERA_PORT_DROP_EVENTS_CNT]);
+	stats->undersize = __le64_to_cpu(hw_val[PRESTERA_PORT_UNDERSIZE_PKTS_CNT]);
+	stats->fragments = __le64_to_cpu(hw_val[PRESTERA_PORT_FRAGMENTS_PKTS_CNT]);
+	stats->oversize = __le64_to_cpu(hw_val[PRESTERA_PORT_OVERSIZE_PKTS_CNT]);
+	stats->jabber = __le64_to_cpu(hw_val[PRESTERA_PORT_JABBER_PKTS_CNT]);
 	stats->rx_error_frame_received =
-		hw_val[PRESTERA_PORT_MAC_RCV_ERROR_CNT];
-	stats->bad_crc = hw_val[PRESTERA_PORT_BAD_CRC_CNT];
-	stats->collisions = hw_val[PRESTERA_PORT_COLLISIONS_CNT];
-	stats->late_collision = hw_val[PRESTERA_PORT_LATE_COLLISIONS_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_MAC_RCV_ERROR_CNT]);
+	stats->bad_crc = __le64_to_cpu(hw_val[PRESTERA_PORT_BAD_CRC_CNT]);
+	stats->collisions = __le64_to_cpu(hw_val[PRESTERA_PORT_COLLISIONS_CNT]);
+	stats->late_collision = __le64_to_cpu(hw_val[PRESTERA_PORT_LATE_COLLISIONS_CNT]);
 	stats->unicast_frames_received =
-		hw_val[PRESTERA_PORT_GOOD_UC_PKTS_RCV_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_GOOD_UC_PKTS_RCV_CNT]);
 	stats->unicast_frames_sent =
-		hw_val[PRESTERA_PORT_GOOD_UC_PKTS_SENT_CNT];
-	stats->sent_multiple = hw_val[PRESTERA_PORT_MULTIPLE_PKTS_SENT_CNT];
-	stats->sent_deferred = hw_val[PRESTERA_PORT_DEFERRED_PKTS_SENT_CNT];
-	stats->good_octets_sent = hw_val[PRESTERA_PORT_GOOD_OCTETS_SENT_CNT];
+		__le64_to_cpu(hw_val[PRESTERA_PORT_GOOD_UC_PKTS_SENT_CNT]);
+	stats->sent_multiple = __le64_to_cpu(hw_val[PRESTERA_PORT_MULTIPLE_PKTS_SENT_CNT]);
+	stats->sent_deferred = __le64_to_cpu(hw_val[PRESTERA_PORT_DEFERRED_PKTS_SENT_CNT]);
+	stats->good_octets_sent = __le64_to_cpu(hw_val[PRESTERA_PORT_GOOD_OCTETS_SENT_CNT]);
 
 	return 0;
 }
@@ -1569,14 +1755,14 @@ int prestera_hw_bridge_create(const struct prestera_switch *sw, u16 *bridge_id)
 	if (err)
 		return err;
 
-	*bridge_id = resp.bridge;
+	*bridge_id = __le16_to_cpu(resp.bridge);
 	return err;
 }
 
 int prestera_hw_bridge_delete(const struct prestera_switch *sw, u16 bridge_id)
 {
 	struct prestera_msg_bridge_req req = {
-		.bridge = bridge_id
+		.bridge = __cpu_to_le16(bridge_id)
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_BRIDGE_DELETE, &req);
@@ -1585,9 +1771,9 @@ int prestera_hw_bridge_delete(const struct prestera_switch *sw, u16 bridge_id)
 int prestera_hw_bridge_port_add(const struct prestera_port *port, u16 bridge_id)
 {
 	struct prestera_msg_bridge_req req = {
-		.bridge = bridge_id,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.bridge = __cpu_to_le16(bridge_id),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_BRIDGE_PORT_ADD, &req);
@@ -1597,9 +1783,9 @@ int prestera_hw_bridge_port_delete(const struct prestera_port *port,
 				   u16 bridge_id)
 {
 	struct prestera_msg_bridge_req req = {
-		.bridge = bridge_id,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.bridge = __cpu_to_le16(bridge_id),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_BRIDGE_PORT_DELETE,
@@ -1610,8 +1796,8 @@ int prestera_hw_macvlan_add(const struct prestera_switch *sw, u16 vr_id,
 			    const u8 *mac, u16 vid)
 {
 	struct prestera_msg_macvlan_req req = {
-		.vr_id = vr_id,
-		.vid = vid
+		.vr_id = __cpu_to_le16(vr_id),
+		.vid = __cpu_to_le16(vid)
 	};
 
 	memcpy(req.mac, mac, ETH_ALEN);
@@ -1623,8 +1809,8 @@ int prestera_hw_macvlan_del(const struct prestera_switch *sw, u16 vr_id,
 			    const u8 *mac, u16 vid)
 {
 	struct prestera_msg_macvlan_req req = {
-		.vr_id = vr_id,
-		.vid = vid
+		.vr_id = __cpu_to_le16(vr_id),
+		.vid = __cpu_to_le16(vid)
 	};
 
 	memcpy(req.mac, mac, ETH_ALEN);
@@ -1637,10 +1823,10 @@ int prestera_hw_fdb_flush_port(const struct prestera_port *port, u32 mode)
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT,
 		.dest = {
-			.dev = port->dev_id,
-			.port = port->hw_id,
+			.dev = __cpu_to_le32(port->dev_id),
+			.port = __cpu_to_le32(port->hw_id),
 		},
-		.flush_mode = mode,
+		.flush_mode = __cpu_to_le32(mode),
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT, &req);
@@ -1651,8 +1837,8 @@ int prestera_hw_fdb_flush_lag(const struct prestera_switch *sw, u16 lag_id,
 {
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,
-		.dest = { .lag_id = lag_id },
-		.flush_mode = mode,
+		.dest = { .lag_id = __cpu_to_le16(lag_id) },
+		.flush_mode = __cpu_to_le32(mode),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT, &req);
@@ -1662,8 +1848,8 @@ int prestera_hw_fdb_flush_vlan(const struct prestera_switch *sw, u16 vid,
 			       u32 mode)
 {
 	struct prestera_msg_fdb_req req = {
-		.vid = vid,
-		.flush_mode = mode,
+		.vid = __cpu_to_le16(vid),
+		.flush_mode = __cpu_to_le32(mode),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_FDB_FLUSH_VLAN, &req);
@@ -1675,11 +1861,11 @@ int prestera_hw_fdb_flush_port_vlan(const struct prestera_port *port, u16 vid,
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT,
 		.dest = {
-			.dev = port->dev_id,
-			.port = port->hw_id,
+			.dev = __cpu_to_le32(port->dev_id),
+			.port = __cpu_to_le32(port->hw_id),
 		},
-		.vid = vid,
-		.flush_mode = mode,
+		.vid = __cpu_to_le16(vid),
+		.flush_mode = __cpu_to_le32(mode),
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT_VLAN,
@@ -1691,9 +1877,9 @@ int prestera_hw_fdb_flush_lag_vlan(const struct prestera_switch *sw,
 {
 	struct prestera_msg_fdb_req req = {
 		.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,
-		.dest = { .lag_id = lag_id },
-		.vid = vid,
-		.flush_mode = mode,
+		.dest = { .lag_id = __cpu_to_le16(lag_id) },
+		.vid = __cpu_to_le16(vid),
+		.flush_mode = __cpu_to_le32(mode),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT_VLAN, &req);
@@ -1704,9 +1890,9 @@ int prestera_hw_port_mac_mode_get(const struct prestera_port *port,
 {
 	struct prestera_msg_port_attr_resp resp;
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_MAC_MODE,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC_MODE),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 	int err;
 
@@ -1716,10 +1902,10 @@ int prestera_hw_port_mac_mode_get(const struct prestera_port *port,
 		return err;
 
 	if (mode)
-		*mode = resp.param.link_evt.mac.mode;
+		*mode = __le32_to_cpu(resp.param.link_evt.mac.mode);
 
 	if (speed)
-		*speed = resp.param.link_evt.mac.speed;
+		*speed = __le32_to_cpu(resp.param.link_evt.mac.speed);
 
 	if (duplex)
 		*duplex = resp.param.link_evt.mac.duplex;
@@ -1735,16 +1921,16 @@ int prestera_hw_port_mac_mode_set(const struct prestera_port *port,
 				  u32 speed, u8 duplex, u8 fec)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_MAC_MODE,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC_MODE),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {
 			.link = {
 				.mac = {
 					.admin = admin,
-					.reg_mode.mode = mode,
+					.reg_mode.mode = __cpu_to_le32(mode),
 					.reg_mode.inband = inband,
-					.reg_mode.speed = speed,
+					.reg_mode.speed = __cpu_to_le32(speed),
 					.reg_mode.duplex = duplex,
 					.reg_mode.fec = fec
 				}
@@ -1761,9 +1947,9 @@ int prestera_hw_port_phy_mode_get(const struct prestera_port *port,
 {
 	struct prestera_msg_port_attr_resp resp;
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_PHY_MODE,
-		.port = port->hw_id,
-		.dev = port->dev_id
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_PHY_MODE),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id)
 	};
 	int err;
 
@@ -1776,7 +1962,7 @@ int prestera_hw_port_phy_mode_get(const struct prestera_port *port,
 		*mdix = prestera_hw_mdix_to_eth(resp.param.link_evt.phy.mdix);
 
 	if (lmode_bmap)
-		*lmode_bmap = resp.param.link_evt.phy.lmode_bmap;
+		*lmode_bmap = __le64_to_cpu(resp.param.link_evt.phy.lmode_bmap);
 
 	if (fc_pause && fc_asym)
 		prestera_hw_remote_fc_to_eth(resp.param.link_evt.phy.fc,
@@ -1790,16 +1976,16 @@ int prestera_hw_port_phy_mode_set(const struct prestera_port *port,
 				  u8 mdix)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_PHY_MODE,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_PHY_MODE),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.param = {
 			.link = {
 				.phy = {
 					.admin = admin,
 					.adv_enable = adv ? 1 : 0,
-					.mode = mode,
-					.modes = modes,
+					.mode = __cpu_to_le32(mode),
+					.modes = __cpu_to_le64(modes),
 				}
 			}
 		}
@@ -1814,10 +2000,10 @@ int prestera_hw_port_storm_control_cfg_set(const struct prestera_port *port,
 					   u32 kbyte_per_sec_rate)
 {
 	struct prestera_msg_port_storm_control_cfg_set_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.storm_type = storm_type,
-		.kbyte_per_sec_rate = kbyte_per_sec_rate
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.storm_type = __cpu_to_le32(storm_type),
+		.kbyte_per_sec_rate = __cpu_to_le32(kbyte_per_sec_rate)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_PORT_RATE_LIMIT_MODE_SET,
@@ -1830,18 +2016,18 @@ static int prestera_iface_to_msg(struct prestera_iface *iface,
 	switch (iface->type) {
 	case PRESTERA_IF_PORT_E:
 	case PRESTERA_IF_VID_E:
-		msg_if->port = iface->dev_port.port_num;
-		msg_if->dev = iface->dev_port.hw_dev_num;
+		msg_if->port = __cpu_to_le32(iface->dev_port.port_num);
+		msg_if->dev = __cpu_to_le32(iface->dev_port.hw_dev_num);
 		break;
 	case PRESTERA_IF_LAG_E:
-		msg_if->lag_id = iface->lag_id;
+		msg_if->lag_id = __cpu_to_le16(iface->lag_id);
 		break;
 	default:
 		return -ENOTSUPP;
 	}
 
-	msg_if->vr_id = iface->vr_id;
-	msg_if->vid = iface->vlan_id;
+	msg_if->vr_id = __cpu_to_le16(iface->vr_id);
+	msg_if->vid = __cpu_to_le16(iface->vlan_id);
 	msg_if->type = iface->type;
 	return 0;
 }
@@ -1864,7 +2050,7 @@ int prestera_hw_rif_create(const struct prestera_switch *sw,
 	if (err)
 		return err;
 
-	*rif_id = resp.rif_id;
+	*rif_id = __le16_to_cpu(resp.rif_id);
 	return err;
 }
 
@@ -1872,7 +2058,7 @@ int prestera_hw_rif_delete(const struct prestera_switch *sw, u16 rif_id,
 			   struct prestera_iface *iif)
 {
 	struct prestera_msg_rif_req req = {
-		.rif_id = rif_id,
+		.rif_id = __cpu_to_le16(rif_id),
 	};
 	int err;
 
@@ -1888,7 +2074,7 @@ int prestera_hw_rif_set(const struct prestera_switch *sw, u16 *rif_id,
 {
 	struct prestera_msg_rif_resp resp;
 	struct prestera_msg_rif_req req = {
-		.rif_id = *rif_id,
+		.rif_id = __cpu_to_le16(*rif_id),
 	};
 	int err;
 
@@ -1903,7 +2089,7 @@ int prestera_hw_rif_set(const struct prestera_switch *sw, u16 *rif_id,
 	if (err)
 		return err;
 
-	*rif_id = resp.rif_id;
+	*rif_id = __le16_to_cpu(resp.rif_id);
 	return err;
 }
 
@@ -1918,14 +2104,14 @@ int prestera_hw_vr_create(const struct prestera_switch *sw, u16 *vr_id)
 	if (err)
 		return err;
 
-	*vr_id = resp.vr_id;
+	*vr_id = __le16_to_cpu(resp.vr_id);
 	return err;
 }
 
 int prestera_hw_vr_delete(const struct prestera_switch *sw, u16 vr_id)
 {
 	struct prestera_msg_vr_req req = {
-		.vr_id = vr_id,
+		.vr_id = __cpu_to_le16(vr_id),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_ROUTER_VR_DELETE, &req);
@@ -1934,7 +2120,7 @@ int prestera_hw_vr_delete(const struct prestera_switch *sw, u16 vr_id)
 int prestera_hw_vr_abort(const struct prestera_switch *sw, u16 vr_id)
 {
 	struct prestera_msg_vr_req req = {
-		.vr_id = vr_id,
+		.vr_id = __cpu_to_le16(vr_id),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_ROUTER_VR_ABORT, &req);
@@ -1946,9 +2132,9 @@ int prestera_hw_lpm_add(const struct prestera_switch *sw, u16 vr_id,
 	struct prestera_msg_lpm_req req = {
 		.dst.v = PRESTERA_IPV4,
 		.dst.u.ipv4 = dst,
-		.dst_len = dst_len,
-		.vr_id = vr_id,
-		.grp_id = grp_id
+		.dst_len = __cpu_to_le32(dst_len),
+		.vr_id = __cpu_to_le16(vr_id),
+		.grp_id = __cpu_to_le32(grp_id)
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_ROUTER_LPM_ADD, &req);
@@ -1960,8 +2146,8 @@ int prestera_hw_lpm_del(const struct prestera_switch *sw, u16 vr_id, __be32 dst,
 	struct prestera_msg_lpm_req req = {
 		.dst.v = PRESTERA_IPV4,
 		.dst.u.ipv4 = dst,
-		.dst_len = dst_len,
-		.vr_id = vr_id,
+		.dst_len = __cpu_to_le32(dst_len),
+		.vr_id = __cpu_to_le16(vr_id),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_ROUTER_LPM_DELETE, &req);
@@ -1970,7 +2156,8 @@ int prestera_hw_lpm_del(const struct prestera_switch *sw, u16 vr_id, __be32 dst,
 int prestera_hw_nh_entries_set(const struct prestera_switch *sw, int count,
 			       struct prestera_neigh_info *nhs, u32 grp_id)
 {
-	struct prestera_msg_nh_req req = { .size = count, .grp_id = grp_id };
+	struct prestera_msg_nh_req req = { .size = __cpu_to_le32((u32)count),
+			.grp_id = __cpu_to_le32(grp_id) };
 	int i, err;
 
 	for (i = 0; i < count; i++) {
@@ -1989,7 +2176,8 @@ int prestera_hw_nh_entries_set(const struct prestera_switch *sw, int count,
 int prestera_hw_nh_entries_get(const struct prestera_switch *sw, int count,
 			       struct prestera_neigh_info *nhs, u32 grp_id)
 {
-	struct prestera_msg_nh_req req = { .size = count, .grp_id = grp_id };
+	struct prestera_msg_nh_req req = { .size = __cpu_to_le32((u32)count),
+			.grp_id = __cpu_to_le32(grp_id) };
 	struct prestera_msg_nh_resp resp;
 	int err, i;
 
@@ -2019,9 +2207,8 @@ int prestera_hw_nhgrp_blk_get(const struct prestera_switch *sw,
 			break;
 
 		memset(&req, 0, sizeof(req));
-		req.offset = buf_offset * 8; /* 8 bits in u8 */
-		err = fw_send_req_resp(sw,
-				       PRESTERA_CMD_TYPE_ROUTER_NH_GRP_BLK_GET,
+		req.offset = __cpu_to_le32(buf_offset * 8); /* 8 bits in u8 */
+		err = fw_send_req_resp(sw, PRESTERA_CMD_TYPE_ROUTER_NH_GRP_BLK_GET,
 				       &req, &resp);
 		if (err)
 			return err;
@@ -2038,7 +2225,7 @@ int prestera_hw_nhgrp_blk_get(const struct prestera_switch *sw,
 int prestera_hw_nh_group_create(const struct prestera_switch *sw, u16 nh_count,
 				u32 *grp_id)
 {
-	struct prestera_msg_nh_grp_req req = { .size = nh_count };
+	struct prestera_msg_nh_grp_req req = { .size = __cpu_to_le32((u32)nh_count) };
 	struct prestera_msg_nh_grp_resp resp;
 	int err;
 
@@ -2047,7 +2234,7 @@ int prestera_hw_nh_group_create(const struct prestera_switch *sw, u16 nh_count,
 	if (err)
 		return err;
 
-	*grp_id = resp.grp_id;
+	*grp_id = __le32_to_cpu(resp.grp_id);
 	return err;
 }
 
@@ -2055,8 +2242,8 @@ int prestera_hw_nh_group_delete(const struct prestera_switch *sw, u16 nh_count,
 				u32 grp_id)
 {
 	struct prestera_msg_nh_grp_req req = {
-	    .grp_id = grp_id,
-	    .size = nh_count
+	    .grp_id = __cpu_to_le32(grp_id),
+	    .size = __cpu_to_le32(nh_count)
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_ROUTER_NH_GRP_DELETE, &req);
@@ -2083,7 +2270,7 @@ int prestera_hw_rxtx_init(const struct prestera_switch *sw, bool use_sdma,
 		return err;
 
 	if (map_addr)
-		*map_addr = resp.map_addr;
+		*map_addr = __le32_to_cpu(resp.map_addr);
 
 	return 0;
 }
@@ -2091,9 +2278,9 @@ int prestera_hw_rxtx_init(const struct prestera_switch *sw, bool use_sdma,
 int prestera_hw_port_autoneg_restart(struct prestera_port *port)
 {
 	struct prestera_msg_port_attr_req req = {
-		.attr = PRESTERA_CMD_PORT_ATTR_PHY_AUTONEG_RESTART,
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_PHY_AUTONEG_RESTART),
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET, &req);
@@ -2103,7 +2290,7 @@ int prestera_hw_port_autoneg_restart(struct prestera_port *port)
 static int acl_rule_add_put_action(struct prestera_msg_acl_action *action,
 				   struct prestera_acl_hw_action_info *info)
 {
-	action->id = info->id;
+	action->id = __cpu_to_le32(info->id);
 
 	switch (info->id) {
 	case PRESTERA_ACL_RULE_ACTION_ACCEPT:
@@ -2114,24 +2301,27 @@ static int acl_rule_add_put_action(struct prestera_msg_acl_action *action,
 		action->trap.hw_tc = info->trap.hw_tc;
 		break;
 	case PRESTERA_ACL_RULE_ACTION_JUMP:
-		action->jump.index = info->jump.index;
+		action->jump.index = __cpu_to_le32(info->jump.index);
 		break;
 	case PRESTERA_ACL_RULE_ACTION_POLICE:
-		action->police.rate = info->police.rate;
-		action->police.burst = info->police.burst;
+		action->police.rate = __cpu_to_le64(info->police.rate);
+		action->police.burst = __cpu_to_le64(info->police.burst);
 		break;
 	case PRESTERA_ACL_RULE_ACTION_NH:
-		action->nh.nh_id = info->nh;
+		action->nh.nh_id = __cpu_to_le32(info->nh);
 		break;
 	case PRESTERA_ACL_RULE_ACTION_NAT:
 		action->nat.old_addr = info->nat.old_addr;
 		action->nat.new_addr = info->nat.new_addr;
-		action->nat.flags = info->nat.flags;
-		action->nat.port = info->nat.port;
-		action->nat.dev = info->nat.dev;
+		action->nat.flags = __cpu_to_le32(info->nat.flags);
+		action->nat.port = __cpu_to_le32(info->nat.port);
+		action->nat.dev = __cpu_to_le32(info->nat.dev);
 		break;
 	case PRESTERA_ACL_RULE_ACTION_COUNT:
-		action->count.id = info->count.id;
+		action->count.id = __cpu_to_le32(info->count.id);
+		break;
+	case PRESTERA_ACL_RULE_ACTION_REMARK:
+		action->remark.dscp = info->remark.dscp;
 		break;
 	default:
 		return -EINVAL;
@@ -2143,7 +2333,7 @@ static int acl_rule_add_put_action(struct prestera_msg_acl_action *action,
 int prestera_hw_counter_trigger(const struct prestera_switch *sw, u32 block_id)
 {
 	struct prestera_msg_counter_req req = {
-		.block_id = block_id
+		.block_id = __cpu_to_le32(block_id)
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_COUNTER_TRIGGER, &req);
@@ -2162,8 +2352,8 @@ int prestera_hw_counters_get(const struct prestera_switch *sw, u32 idx,
 {
 	struct prestera_msg_counter_resp *resp;
 	struct prestera_msg_counter_req req = {
-		.block_id = idx,
-		.num_counters = *len,
+		.block_id = __cpu_to_le32(idx),
+		.num_counters = __cpu_to_le32(*len),
 	};
 	size_t size = sizeof(*resp) + sizeof(*resp->stats) * (*len);
 	int err, i;
@@ -2177,12 +2367,12 @@ int prestera_hw_counters_get(const struct prestera_switch *sw, u32 idx,
 	if (err)
 		goto free_buff;
 
-	for (i = 0; i < resp->num_counters; i++) {
-		stats[i].packets += resp->stats[i].packets;
-		stats[i].bytes += resp->stats[i].bytes;
+	for (i = 0; i < __le32_to_cpu(resp->num_counters); i++) {
+		stats[i].packets += __le64_to_cpu(resp->stats[i].packets);
+		stats[i].bytes += __le64_to_cpu(resp->stats[i].bytes);
 	}
 
-	*len = resp->num_counters;
+	*len = __le32_to_cpu(resp->num_counters);
 	*done = resp->done;
 
 free_buff:
@@ -2190,43 +2380,24 @@ int prestera_hw_counters_get(const struct prestera_switch *sw, u32 idx,
 	return err;
 }
 
-static u32 prestera_client_to_agent(enum prestera_counter_client client)
-{
-	switch (client) {
-	case PRESTERA_COUNTER_CLIENT_LOOKUP_0:
-		return PRESTERA_HW_COUNTER_CLIENT_LOOKUP_0;
-	case PRESTERA_COUNTER_CLIENT_LOOKUP_1:
-		return PRESTERA_HW_COUNTER_CLIENT_LOOKUP_1;
-	case PRESTERA_COUNTER_CLIENT_LOOKUP_2:
-		return PRESTERA_HW_COUNTER_CLIENT_LOOKUP_2;
-	case PRESTERA_COUNTER_CLIENT_LOOKUP_LAST:
-	default:
-		return -ENOTSUPP;
-	}
-}
-
 int prestera_hw_counter_block_get(const struct prestera_switch *sw,
-				  enum prestera_counter_client client,
-				  u32 *block_id, u32 *offset,
+				  u32 client, u32 *block_id, u32 *offset,
 				  u32 *num_counters)
 {
 	struct prestera_msg_counter_resp resp;
 	struct prestera_msg_counter_req req = {
-		.client = prestera_client_to_agent(client)
+		.client = __cpu_to_le32(client)
 	};
 	int err = 0;
 
-	if (req.client == -ENOTSUPP)
-		return -ENOTSUPP;
-
 	err = fw_send_req_resp(sw, PRESTERA_CMD_TYPE_COUNTER_BLOCK_GET,
 			       &req, &resp);
 	if (err)
 		return err;
 
-	*block_id = resp.block_id;
-	*offset = resp.offset;
-	*num_counters = resp.num_counters;
+	*block_id = __le32_to_cpu(resp.block_id);
+	*offset = __le32_to_cpu(resp.offset);
+	*num_counters = __le32_to_cpu(resp.num_counters);
 
 	return 0;
 }
@@ -2235,7 +2406,7 @@ int prestera_hw_counter_block_release(const struct prestera_switch *sw,
 				      u32 block_id)
 {
 	struct prestera_msg_counter_req req = {
-		.block_id = block_id
+		.block_id = __cpu_to_le32(block_id)
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_COUNTER_BLOCK_RELEASE, &req);
@@ -2245,8 +2416,8 @@ int prestera_hw_counter_clear(const struct prestera_switch *sw, u32 block_id,
 			      u32 counter_id)
 {
 	struct prestera_msg_counter_req req = {
-		.block_id = block_id,
-		.num_counters = counter_id,
+		.block_id = __cpu_to_le32(block_id),
+		.num_counters = __cpu_to_le32(counter_id),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_COUNTER_CLEAR, &req);
@@ -2256,8 +2427,8 @@ int prestera_hw_nat_port_neigh_update(const struct prestera_port *port,
 				      unsigned char *mac)
 {
 	struct prestera_msg_nat_port_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 	};
 	memcpy(req.neigh_mac, mac, sizeof(req.neigh_mac));
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_NAT_PORT_NEIGH_UPDATE,
@@ -2277,7 +2448,7 @@ int prestera_hw_nh_mangle_add(const struct prestera_switch *sw, u32 *nh_id)
 	if (err)
 		return err;
 
-	*nh_id = resp.nh_id;
+	*nh_id = __le32_to_cpu(resp.nh_id);
 	return 0;
 }
 
@@ -2286,7 +2457,7 @@ int prestera_hw_nh_mangle_del(const struct prestera_switch *sw, u32 nh_id)
 	struct prestera_msg_nh_mangle_req req;
 
 	memset(&req, 0, sizeof(req));
-	req.nh_id = nh_id;
+	req.nh_id = __cpu_to_le32(nh_id);
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_NAT_NH_MANGLE_DEL, &req);
 }
 
@@ -2304,7 +2475,7 @@ int prestera_hw_nh_mangle_set(const struct prestera_switch *sw, u32 nh_id,
 		return -EINVAL;
 
 	memset(&req, 0, sizeof(req));
-	req.nh_id = nh_id;
+	req.nh_id = __cpu_to_le32(nh_id);
 	req.info.l4_src_valid = l4_src_valid;
 	req.info.l4_dst_valid = l4_dst_valid;
 	req.info.sip_valid = sip_valid;
@@ -2330,7 +2501,7 @@ int prestera_hw_nh_mangle_get(const struct prestera_switch *sw, u32 nh_id,
 	int err;
 
 	memset(&req, 0, sizeof(req));
-	req.nh_id = nh_id;
+	req.nh_id = __cpu_to_le32(nh_id);
 	memset(&resp, 0, sizeof(resp));
 	err = fw_send_req_resp(sw, PRESTERA_CMD_TYPE_NAT_NH_MANGLE_GET, &req,
 			       &resp);
@@ -2346,8 +2517,8 @@ int prestera_hw_span_get(const struct prestera_port *port, u8 *span_id)
 	int err;
 	struct prestera_msg_span_resp resp;
 	struct prestera_msg_span_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 	};
 
 	err = fw_send_req_resp(port->sw, PRESTERA_CMD_TYPE_SPAN_GET,
@@ -2363,8 +2534,8 @@ int prestera_hw_span_get(const struct prestera_port *port, u8 *span_id)
 int prestera_hw_span_bind(const struct prestera_port *port, u8 span_id)
 {
 	struct prestera_msg_span_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 		.id = span_id,
 	};
 
@@ -2374,8 +2545,8 @@ int prestera_hw_span_bind(const struct prestera_port *port, u8 span_id)
 int prestera_hw_span_unbind(const struct prestera_port *port)
 {
 	struct prestera_msg_span_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_SPAN_UNBIND, &req);
@@ -2393,9 +2564,9 @@ int prestera_hw_span_release(const struct prestera_switch *sw, u8 span_id)
 int prestera_hw_lag_member_add(struct prestera_port *port, u16 lag_id)
 {
 	struct prestera_msg_lag_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.lag_id = lag_id
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.lag_id = __cpu_to_le16(lag_id)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_LAG_ADD, &req);
@@ -2404,9 +2575,9 @@ int prestera_hw_lag_member_add(struct prestera_port *port, u16 lag_id)
 int prestera_hw_lag_member_del(struct prestera_port *port, u16 lag_id)
 {
 	struct prestera_msg_lag_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.lag_id = lag_id
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.lag_id = __cpu_to_le16(lag_id)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_LAG_DELETE, &req);
@@ -2417,9 +2588,9 @@ int prestera_hw_lag_member_enable(struct prestera_port *port, u16 lag_id,
 {
 	u32 cmd;
 	struct prestera_msg_lag_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.lag_id = lag_id
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.lag_id = __cpu_to_le16(lag_id)
 	};
 
 	cmd = enable ? PRESTERA_CMD_TYPE_LAG_ENABLE :
@@ -2431,10 +2602,10 @@ int prestera_hw_lag_member_rif_leave(const struct prestera_port *port,
 				     u16 lag_id, u16 vr_id)
 {
 	struct prestera_msg_lag_req req = {
-		.port = port->hw_id,
-		.dev = port->dev_id,
-		.lag_id = lag_id,
-		.vr_id = vr_id
+		.port = __cpu_to_le32(port->hw_id),
+		.dev = __cpu_to_le32(port->dev_id),
+		.lag_id = __cpu_to_le16(lag_id),
+		.vr_id = __cpu_to_le16(vr_id)
 	};
 
 	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_LAG_ROUTER_LEAVE, &req);
@@ -2457,14 +2628,14 @@ prestera_hw_cpu_code_counters_get(const struct prestera_switch *sw, u8 code,
 	if (err)
 		return err;
 
-	*packet_count = resp.packet_count;
+	*packet_count = __le64_to_cpu(resp.packet_count);
 
 	return 0;
 }
 
 int prestera_hw_vtcam_create(const struct prestera_switch *sw,
 			     u8 lookup, const u32 *keymask, u32 *vtcam_id,
-			     enum prestera_hw_vtcam_direction_t dir)
+			     u8 dir)
 {
 	int err;
 	struct prestera_msg_vtcam_resp resp;
@@ -2482,14 +2653,14 @@ int prestera_hw_vtcam_create(const struct prestera_switch *sw,
 	if (err)
 		return err;
 
-	*vtcam_id = resp.vtcam_id;
+	*vtcam_id = __le32_to_cpu(resp.vtcam_id);
 	return 0;
 }
 
 int prestera_hw_vtcam_destroy(const struct prestera_switch *sw, u32 vtcam_id)
 {
 	struct prestera_msg_vtcam_destroy_req req = {
-		.vtcam_id = vtcam_id,
+		.vtcam_id = __cpu_to_le32(vtcam_id),
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_VTCAM_DESTROY, &req);
@@ -2515,7 +2686,7 @@ int prestera_hw_vtcam_rule_add(const struct prestera_switch *sw,
 		return -ENOMEM;
 
 	req = buff;
-	req->n_act = n_act;
+	req->n_act = __cpu_to_le32((u32)n_act);
 	actions_msg = buff + sizeof(*req);
 
 	/* put acl matches into the message */
@@ -2529,15 +2700,15 @@ int prestera_hw_vtcam_rule_add(const struct prestera_switch *sw,
 			goto free_buff;
 	}
 
-	req->vtcam_id = vtcam_id;
-	req->prio = prio;
+	req->vtcam_id = __cpu_to_le32(vtcam_id);
+	req->prio = __cpu_to_le32(prio);
 
 	err = fw_send_nreq_resp(sw, PRESTERA_CMD_TYPE_VTCAM_RULE_ADD, req,
 				size, &resp);
 	if (err)
 		goto free_buff;
 
-	*rule_id = resp.rule_id;
+	*rule_id = __le32_to_cpu(resp.rule_id);
 free_buff:
 	kfree(buff);
 	return err;
@@ -2547,8 +2718,8 @@ int prestera_hw_vtcam_rule_del(const struct prestera_switch *sw,
 			       u32 vtcam_id, u32 rule_id)
 {
 	struct prestera_msg_vtcam_rule_del_req req = {
-		.vtcam_id = vtcam_id,
-		.id = rule_id
+		.vtcam_id = __cpu_to_le32(vtcam_id),
+		.id = __cpu_to_le32(rule_id)
 	};
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_VTCAM_RULE_DELETE, &req);
@@ -2559,16 +2730,16 @@ int prestera_hw_vtcam_iface_bind(const struct prestera_switch *sw,
 				 u32 vtcam_id, u16 pcl_id)
 {
 	struct prestera_msg_vtcam_bind_req req = {
-		.vtcam_id = vtcam_id,
-		.type = iface->type,
-		.pcl_id = pcl_id
+		.vtcam_id = __cpu_to_le32(vtcam_id),
+		.type = __cpu_to_le16(iface->type),
+		.pcl_id = __cpu_to_le16(pcl_id)
 	};
 
 	if (iface->type == PRESTERA_ACL_IFACE_TYPE_PORT) {
-		req.port.dev_id = iface->port->dev_id;
-		req.port.hw_id = iface->port->hw_id;
+		req.port.dev_id = __cpu_to_le32(iface->port->dev_id);
+		req.port.hw_id = __cpu_to_le32(iface->port->hw_id);
 	} else {
-		req.index = iface->index;
+		req.index = __cpu_to_le32(iface->index);
 	}
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_VTCAM_IFACE_BIND, &req);
@@ -2579,23 +2750,191 @@ int prestera_hw_vtcam_iface_unbind(const struct prestera_switch *sw,
 				   u32 vtcam_id)
 {
 	struct prestera_msg_vtcam_bind_req req = {
-		.vtcam_id = vtcam_id,
-		.type = iface->type,
+		.vtcam_id = __cpu_to_le32(vtcam_id),
+		.type = __cpu_to_le16(iface->type),
 	};
 
 	if (iface->type == PRESTERA_ACL_IFACE_TYPE_PORT) {
-		req.port.dev_id = iface->port->dev_id;
-		req.port.hw_id = iface->port->hw_id;
+		req.port.dev_id = __cpu_to_le32(iface->port->dev_id);
+		req.port.hw_id = __cpu_to_le32(iface->port->hw_id);
 	} else {
-		req.index = iface->index;
+		req.index = __cpu_to_le32(iface->index);
 	}
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_VTCAM_IFACE_UNBIND, &req);
 }
 
+int prestera_hw_port_qos_mapping_update(const struct prestera_port *port,
+					struct dcb_ieee_app_dscp_map *map)
+{
+	struct prestera_msg_qos_req req = {
+		.port = port->hw_id,
+		.dev = port->dev_id,
+	};
+
+	memcpy(req.dscp, map->map, sizeof(req.dscp));
+
+	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_QOS_DSCP_PRIO_MAP_UPDATE,
+			   &req);
+}
+
+int prestera_hw_port_qos_trust_mode_set(const struct prestera_port *port,
+					u8 mode)
+{
+	struct prestera_msg_qos_req req = {
+		.port = port->hw_id,
+		.dev = port->dev_id,
+		.mode = mode,
+	};
+
+	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_QOS_TRUST_MODE_SET,
+			   &req);
+}
+
+int prestera_hw_port_qos_default_prio_set(const struct prestera_port *port,
+					  u32 priority)
+{
+	struct prestera_msg_qos_req req = {
+		.port = port->hw_id,
+		.dev = port->dev_id,
+		.priority = priority,
+	};
+
+	return fw_send_req(port->sw, PRESTERA_CMD_TYPE_QOS_DEFAULT_PRIO_SET,
+			   &req);
+}
+
 int prestera_hw_switch_reset(struct prestera_switch *sw)
 {
 	struct prestera_msg_common_req req;
 
 	return fw_send_req(sw, PRESTERA_CMD_TYPE_SWITCH_RESET, &req);
 }
+
+int prestera_hw_flood_domain_create(struct prestera_flood_domain *domain)
+{
+	struct prestera_msg_flood_domain_create_resp resp;
+	struct prestera_msg_flood_domain_create_req req;
+	int err;
+
+	err = fw_send_req_resp(domain->sw,
+			       PRESTERA_CMD_TYPE_FLOOD_DOMAIN_CREATE, &req,
+			       &resp);
+	if (err)
+		return err;
+
+	domain->idx = __le32_to_cpu(resp.flood_domain_idx);
+
+	return 0;
+}
+
+int prestera_hw_flood_domain_destroy(struct prestera_flood_domain *domain)
+{
+	struct prestera_msg_flood_domain_destroy_req req = {
+		.flood_domain_idx = __cpu_to_le32(domain->idx),
+	};
+
+	return fw_send_req(domain->sw, PRESTERA_CMD_TYPE_FLOOD_DOMAIN_DESTROY,
+			   &req);
+}
+
+int prestera_hw_flood_domain_ports_set(struct prestera_flood_domain *domain)
+{
+	struct prestera_flood_domain_port *flood_domain_port;
+	struct prestera_msg_flood_domain_ports_set_req *req;
+	struct prestera_msg_flood_domain_port *ports;
+	struct prestera_msg_common_resp resp = {0}; /* todo: generic macro to be used */
+	struct prestera_switch *sw = domain->sw;
+	struct prestera_port *port;
+	u32 ports_num = 0;
+	int buf_size;
+	void *buff;
+	u16 lag_id;
+	int err;
+
+	list_for_each_entry(flood_domain_port, &domain->flood_domain_port_list,
+			    flood_domain_port_node)
+		ports_num++;
+
+	if (!ports_num)
+		return -EINVAL;
+
+	buf_size = sizeof(*req) + sizeof(*ports) * ports_num;
+
+	buff = kmalloc(buf_size, GFP_KERNEL);
+	if (!buff)
+		return -ENOMEM;
+
+	req = buff;
+	ports = buff + sizeof(*req);
+
+	req->flood_domain_idx = __cpu_to_le32(domain->idx);
+	req->ports_num = __cpu_to_le32(ports_num);
+
+	list_for_each_entry(flood_domain_port, &domain->flood_domain_port_list,
+			    flood_domain_port_node) {
+		if (netif_is_lag_master(flood_domain_port->dev)) {
+			if (prestera_lag_id_find(sw, flood_domain_port->dev,
+						 &lag_id)) {
+				kfree(buff);
+				return -EINVAL;
+			}
+
+			ports->port_type =
+				__cpu_to_le16(PRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_LAG);
+			ports->lag_id = __cpu_to_le16(lag_id);
+		} else {
+			port = prestera_port_dev_lower_find(flood_domain_port->dev);
+
+			ports->port_type =
+				__cpu_to_le16(PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT);
+			ports->dev_num = __cpu_to_le32(port->dev_id);
+			ports->port_num = __cpu_to_le32(port->hw_id);
+		}
+
+		ports->vid = __cpu_to_le16(flood_domain_port->vid);
+
+		ports++;
+	}
+
+	err = fw_send_nreq_resp(sw, PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_SET,
+				req, buf_size, &resp);
+
+	kfree(buff);
+
+	return err;
+}
+
+int prestera_hw_flood_domain_ports_reset(struct prestera_flood_domain *domain)
+{
+	struct prestera_msg_flood_domain_ports_reset_req req = {
+		.flood_domain_idx = __cpu_to_le32(domain->idx),
+	};
+
+	return fw_send_req(domain->sw,
+			   PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_RESET, &req);
+}
+
+int prestera_hw_mdb_create(struct prestera_mdb_entry *mdb)
+{
+	struct prestera_msg_mdb_create_req req = {
+		.flood_domain_idx = __cpu_to_le32(mdb->flood_domain->idx),
+		.vid = __cpu_to_le16(mdb->vid),
+	};
+
+	memcpy(req.mac, mdb->addr, ETH_ALEN);
+
+	return fw_send_req(mdb->sw, PRESTERA_CMD_TYPE_MDB_CREATE, &req);
+}
+
+int prestera_hw_mdb_destroy(struct prestera_mdb_entry *mdb)
+{
+	struct prestera_msg_mdb_destroy_req req = {
+		.flood_domain_idx = __cpu_to_le32(mdb->flood_domain->idx),
+		.vid = __cpu_to_le16(mdb->vid),
+	};
+
+	memcpy(req.mac, mdb->addr, ETH_ALEN);
+
+	return fw_send_req(mdb->sw, PRESTERA_CMD_TYPE_MDB_DESTROY, &req);
+}
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_hw.h b/drivers/net/ethernet/marvell/prestera/prestera_hw.h
index 65fbe0c..3bb50f7 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_hw.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera_hw.h
@@ -179,11 +179,22 @@ enum prestera_hw_cpu_code_cnt_t {
 	PRESTERA_HW_CPU_CODE_CNT_TYPE_TRAP = 1,
 };
 
-enum prestera_hw_vtcam_direction_t {
+enum {
 	PRESTERA_HW_VTCAM_DIR_INGRESS = 0,
 	PRESTERA_HW_VTCAM_DIR_EGRESS = 1,
 };
 
+enum {
+	PRESTERA_HW_COUNTER_CLIENT_LOOKUP_0 = 0,
+	PRESTERA_HW_COUNTER_CLIENT_LOOKUP_1 = 1,
+	PRESTERA_HW_COUNTER_CLIENT_LOOKUP_2 = 2,
+};
+
+enum {
+	PRESTERA_HW_QOS_TRUST_MODE_L2 = 0,
+	PRESTERA_HW_QOS_TRUST_MODE_L3 = 1,
+};
+
 struct prestera_switch;
 struct prestera_port;
 struct prestera_port_stats;
@@ -195,7 +206,6 @@ struct prestera_neigh_info;
 struct prestera_counter_stats;
 struct prestera_acl_iface;
 
-enum prestera_counter_client;
 enum prestera_event_type;
 struct prestera_event;
 
@@ -286,10 +296,8 @@ int prestera_hw_counter_abort(const struct prestera_switch *sw);
 int prestera_hw_counters_get(const struct prestera_switch *sw, u32 idx,
 			     u32 *len, bool *done,
 			     struct prestera_counter_stats *stats);
-int prestera_hw_counter_block_get(const struct prestera_switch *sw,
-				  enum prestera_counter_client client,
-				  u32 *block_id, u32 *offset,
-				  u32 *num_counters);
+int prestera_hw_counter_block_get(const struct prestera_switch *sw, u32 client,
+				  u32 *block_id, u32 *offset, u32 *num_counters);
 int prestera_hw_counter_block_release(const struct prestera_switch *sw,
 				      u32 block_id);
 int prestera_hw_counter_clear(const struct prestera_switch *sw, u32 block_id,
@@ -298,7 +306,7 @@ int prestera_hw_counter_clear(const struct prestera_switch *sw, u32 block_id,
 /* vTCAM API */
 int prestera_hw_vtcam_create(const struct prestera_switch *sw,
 			     u8 lookup, const u32 *keymask, u32 *vtcam_id,
-			     enum prestera_hw_vtcam_direction_t direction);
+			     u8 direction);
 int prestera_hw_vtcam_rule_add(const struct prestera_switch *sw, u32 vtcam_id,
 			       u32 prio, void *key, void *keymask,
 			       struct prestera_acl_hw_action_info *act,
@@ -410,4 +418,21 @@ prestera_hw_cpu_code_counters_get(const struct prestera_switch *sw, u8 code,
 				  enum prestera_hw_cpu_code_cnt_t counter_type,
 				  u64 *packet_count);
 
+/* Flood domain / MDB API */
+int prestera_hw_flood_domain_create(struct prestera_flood_domain *domain);
+int prestera_hw_flood_domain_destroy(struct prestera_flood_domain *domain);
+int prestera_hw_flood_domain_ports_set(struct prestera_flood_domain *domain);
+int prestera_hw_flood_domain_ports_reset(struct prestera_flood_domain *domain);
+
+int prestera_hw_mdb_create(struct prestera_mdb_entry *mdb);
+int prestera_hw_mdb_destroy(struct prestera_mdb_entry *mdb);
+
+/* QoS */
+int prestera_hw_port_qos_mapping_update(const struct prestera_port *port,
+					struct dcb_ieee_app_dscp_map *map);
+int prestera_hw_port_qos_trust_mode_set(const struct prestera_port *port,
+					u8 mode);
+int prestera_hw_port_qos_default_prio_set(const struct prestera_port *port,
+					  u32 priority);
+
 #endif /* _PRESTERA_HW_H_ */
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_main.c b/drivers/net/ethernet/marvell/prestera/prestera_main.c
index 3d1d573..99a0ad3 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_main.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_main.c
@@ -28,6 +28,7 @@
 #include "prestera_drv_ver.h"
 #include "prestera_counter.h"
 #include "prestera_switchdev.h"
+#include "prestera_dcb.h"
 
 static u8 trap_policer_profile = 1;
 
@@ -453,6 +454,22 @@ int prestera_port_cfg_mac_write(struct prestera_port *port,
 	return 0;
 }
 
+void prestera_port_mac_state_cache_read(struct prestera_port *port,
+					struct prestera_port_mac_state *state)
+{
+	read_lock(&port->state_mac_lock);
+	*state = port->state_mac;
+	read_unlock(&port->state_mac_lock);
+}
+
+void prestera_port_mac_state_cache_write(struct prestera_port *port,
+					 struct prestera_port_mac_state *state)
+{
+	write_lock(&port->state_mac_lock);
+	port->state_mac = *state;
+	write_unlock(&port->state_mac_lock);
+}
+
 /* TODO:  Rename, that it only for integral */
 int prestera_port_autoneg_set(struct prestera_port *port, u64 link_modes)
 {
@@ -718,17 +735,20 @@ static void prestera_mac_pcs_get_state(struct phylink_config *config,
 {
 	struct net_device *ndev = to_net_dev(config->dev);
 	struct prestera_port *port = netdev_priv(ndev);
+	struct prestera_port_mac_state smac;
 
-	state->link = port->state_mac.oper;
-	state->pause = 0;
+	prestera_port_mac_state_cache_read(port, &smac);
 
-	if (port->state_mac.oper) {
+	if (smac.valid) {
+		state->link = smac.oper;
+		state->pause = 0;
 		/* AN is completed, when port is up */
-		state->an_complete = port->autoneg;
-
-		state->speed = port->state_mac.speed;
-		state->duplex = port->state_mac.duplex;
+		state->an_complete = smac.oper ? port->autoneg : false;
+		state->speed = smac.speed;
+		state->duplex = smac.duplex;
 	} else {
+		state->link = false;
+		state->pause = 0;
 		state->an_complete = false;
 		state->speed = SPEED_UNKNOWN;
 		state->duplex = DUPLEX_UNKNOWN;
@@ -806,8 +826,12 @@ static void prestera_mac_link_down(struct phylink_config *config,
 {
 	struct net_device *ndev = to_net_dev(config->dev);
 	struct prestera_port *port = netdev_priv(ndev);
+	struct prestera_port_mac_state state_mac;
 
-	port->state_mac.oper = false;
+	/* Invalidate. Parameters will update on next link event. */
+	memset(&state_mac, 0, sizeof(state_mac));
+	state_mac.valid = false;
+	prestera_port_mac_state_cache_write(port, &state_mac);
 }
 
 static void prestera_mac_link_up(struct phylink_config *config,
@@ -1023,6 +1047,13 @@ static int __prestera_ports_alloc(struct prestera_switch *sw)
 			}
 		}
 
+		prestera_port_dcb_init(port);
+
+		/* initialize state_mac */
+		rwlock_init(&port->state_mac_lock);
+
+		/* TODO: initialize state_phy */
+
 		prestera_port_uc_flood_set(port, false);
 		prestera_port_mc_flood_set(port, false);
 
@@ -1557,6 +1588,7 @@ static void __prestera_ports_free(struct prestera_switch *sw)
 		prestera_port_vlan_flush(port, true);
 		WARN_ON_ONCE(!list_empty(&port->vlans_list));
 		prestera_port_router_leave(port);
+		prestera_port_dcb_fini(port);
 
 		list_del(pos);
 		free_percpu(port->rxtx_stats);
@@ -1602,19 +1634,33 @@ static void prestera_port_handle_event(struct prestera_switch *sw,
 {
 	struct prestera_port *port;
 	struct delayed_work *caching_dw;
-
-	port = __find_pr_port(sw, evt->port_evt.port_id);
-	if (!port)
-		return;
-
-	caching_dw = &port->cached_hw_stats.caching_dw;
-
-	prestera_ethtool_port_state_changed(port, &evt->port_evt);
+	struct prestera_port_mac_state smac;
+	struct prestera_port_event *pevt;
 
 	switch (evt->id) {
 	case PRESTERA_PORT_EVENT_MAC_STATE_CHANGED:
+		pevt = &evt->port_evt;
+
+		port = __find_pr_port(sw, pevt->port_id);
+		if (!port)
+			return;
+
+		caching_dw = &port->cached_hw_stats.caching_dw;
+
+		memset(&smac, 0, sizeof(smac));
+		smac.valid = true;
+		smac.oper = pevt->data.mac.oper;
+		if (smac.oper) {
+			smac.mode = pevt->data.mac.mode;
+			smac.speed = pevt->data.mac.speed;
+			smac.duplex = pevt->data.mac.duplex;
+			smac.fc = pevt->data.mac.fc;
+			smac.fec = pevt->data.mac.fec;
+		}
 
-		if (port->state_mac.oper) {
+		prestera_port_mac_state_cache_write(port, &smac);
+
+		if (pevt->data.mac.oper) {
 #ifdef CONFIG_PHYLINK
 			if (port->phy_link)
 				phylink_mac_change(port->phy_link, true);
@@ -2139,6 +2185,150 @@ static void prestera_netdev_event_handler_unregister(struct prestera_switch *sw)
 	unregister_netdevice_notifier(&sw->netdev_nb);
 }
 
+struct prestera_mdb_entry *
+prestera_mdb_entry_create(struct prestera_switch *sw,
+			  const unsigned char *addr, u16 vid)
+{
+	struct prestera_flood_domain *flood_domain;
+	struct prestera_mdb_entry *mdb_entry;
+
+	mdb_entry = kzalloc(sizeof(*mdb_entry), GFP_KERNEL);
+	if (!mdb_entry)
+		goto err_mdb_alloc;
+
+	flood_domain = prestera_flood_domain_create(sw);
+	if (!flood_domain)
+		goto err_flood_domain_create;
+
+	mdb_entry->sw = sw;
+	mdb_entry->vid = vid;
+	mdb_entry->flood_domain = flood_domain;
+	ether_addr_copy(mdb_entry->addr, addr);
+
+	if (prestera_hw_mdb_create(mdb_entry))
+		goto err_mdb_hw_create;
+
+	return mdb_entry;
+
+err_mdb_hw_create:
+	prestera_hw_mdb_destroy(mdb_entry);
+err_flood_domain_create:
+	kfree(mdb_entry);
+err_mdb_alloc:
+	return NULL;
+}
+
+void prestera_mdb_entry_destroy(struct prestera_mdb_entry *mdb_entry)
+{
+	prestera_hw_mdb_destroy(mdb_entry);
+	prestera_flood_domain_destroy(mdb_entry->flood_domain);
+	kfree(mdb_entry);
+}
+
+struct prestera_flood_domain *
+prestera_flood_domain_create(struct prestera_switch *sw)
+{
+	struct prestera_flood_domain *domain;
+
+	domain = kzalloc(sizeof(domain), GFP_KERNEL);
+	if (!domain)
+		return NULL;
+
+	domain->sw = sw;
+
+	if (prestera_hw_flood_domain_create(domain)) {
+		kfree(domain);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&domain->flood_domain_port_list);
+
+	return domain;
+}
+
+void prestera_flood_domain_destroy(struct prestera_flood_domain *flood_domain)
+{
+	WARN_ON(!list_empty(&flood_domain->flood_domain_port_list));
+	WARN_ON_ONCE(prestera_hw_flood_domain_destroy(flood_domain));
+	kfree(flood_domain);
+}
+
+int
+prestera_flood_domain_port_create(struct prestera_flood_domain *flood_domain,
+				  struct net_device *dev,
+				  u16 vid)
+{
+	struct prestera_flood_domain_port *flood_domain_port;
+	bool is_first_port_in_list = false;
+	int err;
+
+	flood_domain_port = kzalloc(sizeof(*flood_domain_port), GFP_KERNEL);
+	if (!flood_domain_port) {
+		err = -ENOMEM;
+		goto err_port_alloc;
+	}
+
+	flood_domain_port->vid = vid;
+
+	if (list_empty(&flood_domain->flood_domain_port_list))
+		is_first_port_in_list = true;
+
+	list_add(&flood_domain_port->flood_domain_port_node,
+		 &flood_domain->flood_domain_port_list);
+
+	flood_domain_port->flood_domain = flood_domain;
+	flood_domain_port->dev = dev;
+
+	if (!is_first_port_in_list) {
+		err = prestera_hw_flood_domain_ports_reset(flood_domain);
+		if (err)
+			goto err_prestera_mdb_port_create_hw;
+	}
+
+	err = prestera_hw_flood_domain_ports_set(flood_domain);
+	if (err)
+		goto err_prestera_mdb_port_create_hw;
+
+	return 0;
+
+err_prestera_mdb_port_create_hw:
+	list_del(&flood_domain_port->flood_domain_port_node);
+	kfree(flood_domain_port);
+err_port_alloc:
+	return err;
+}
+
+void
+prestera_flood_domain_port_destroy(struct prestera_flood_domain_port *port)
+{
+	struct prestera_flood_domain *flood_domain = port->flood_domain;
+
+	list_del(&port->flood_domain_port_node);
+
+	WARN_ON_ONCE(prestera_hw_flood_domain_ports_reset(flood_domain));
+
+	if (!list_empty(&flood_domain->flood_domain_port_list))
+		WARN_ON_ONCE(prestera_hw_flood_domain_ports_set(flood_domain));
+
+	kfree(port);
+}
+
+struct prestera_flood_domain_port *
+prestera_flood_domain_port_find(struct prestera_flood_domain *flood_domain,
+				struct net_device *dev, u16 vid)
+{
+	struct prestera_flood_domain_port *flood_domain_port;
+
+	list_for_each_entry(flood_domain_port,
+			    &flood_domain->flood_domain_port_list,
+			    flood_domain_port_node)
+		if (flood_domain_port->dev == dev &&
+		    vid == flood_domain_port->vid)
+			return flood_domain_port;
+
+	return NULL;
+}
+
 static int prestera_init(struct prestera_switch *sw)
 {
 	int err;
@@ -2293,6 +2483,7 @@ void prestera_device_unregister(struct prestera_device *dev)
 	list_del(&sw->list);
 	prestera_fini(sw);
 	prestera_devlink_free(sw);
+	dev->priv = NULL;
 }
 EXPORT_SYMBOL(prestera_device_unregister);
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_pci.c b/drivers/net/ethernet/marvell/prestera/prestera_pci.c
index 16794b7..cfdcd20 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_pci.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_pci.c
@@ -9,49 +9,15 @@
 #include <linux/firmware.h>
 
 #include "prestera.h"
+#include "prestera_fw.h"
 
 #define PRESTERA_FW_DEFAULT_PATH	"marvell/mvsw_prestera_fw.img"
 #define PRESTERA_FW_ARM64_PATH		"marvell/mvsw_prestera_fw_arm64.img"
 
-#define PRESTERA_SUPP_FW_MAJ_VER	3
-#define PRESTERA_SUPP_FW_MIN_VER	1
-#define PRESTERA_SUPP_FW_PATCH_VER	1
-
-#define prestera_wait(cond, waitms) \
-({ \
-	unsigned long __wait_end = jiffies + msecs_to_jiffies(waitms); \
-	bool __wait_ret = false; \
-	do { \
-		if (cond) { \
-			__wait_ret = true; \
-			break; \
-		} \
-		cond_resched(); \
-	} while (time_before(jiffies, __wait_end)); \
-	__wait_ret; \
-})
-
 #define PRESTERA_FW_HDR_MAGIC	0x351D9D06
 #define PRESTERA_FW_DL_TIMEOUT	50000
 #define PRESTERA_FW_BLK_SZ	1024
 
-#define FW_VER_MAJ_MUL 1000000
-#define FW_VER_MIN_MUL 1000
-
-#define FW_VER_MAJ(v)	((v) / FW_VER_MAJ_MUL)
-
-#define FW_VER_MIN(v) \
-	(((v) - (FW_VER_MAJ(v) * FW_VER_MAJ_MUL)) / FW_VER_MIN_MUL)
-
-#define FW_VER_PATCH(v) \
-	(v - (FW_VER_MAJ(v) * FW_VER_MAJ_MUL) - (FW_VER_MIN(v) * FW_VER_MIN_MUL))
-
-struct prestera_fw_header {
-	__be32 magic_number;
-	__be32 version_value;
-	u8 reserved[8];
-} __packed;
-
 struct prestera_ldr_regs {
 	u32 ldr_ready;
 	u32 pad1;
@@ -115,132 +81,6 @@ do { \
 	((__fw)->ldr_ring_buf + (__fw)->ldr_wr_idx); \
 })
 
-#define PRESTERA_EVT_QNUM_MAX	4
-
-struct prestera_fw_evtq_regs {
-	u32 rd_idx;
-	u32 pad1;
-	u32 wr_idx;
-	u32 pad2;
-	u32 offs;
-	u32 len;
-};
-
-#define PRESTERA_CMD_QNUM_MAX	4
-
-struct prestera_fw_cmdq_regs {
-	u32 cmd_req_ctl;
-	u32 cmd_req_len;
-	u32 cmd_rcv_ctl;
-	u32 cmd_rcv_len;
-	u32 offs;
-	u32 len;
-};
-
-struct prestera_fw_regs {
-	u32 fw_ready;
-	u32 cmd_offs;
-	u32 cmd_len;
-	u32 cmd_qnum;
-	u32 evt_offs;
-	u32 evt_qnum;
-
-	u32 fw_status;
-	u32 rx_status;
-
-	struct prestera_fw_cmdq_regs cmdq_list[PRESTERA_CMD_QNUM_MAX];
-	struct prestera_fw_evtq_regs evtq_list[PRESTERA_EVT_QNUM_MAX];
-};
-
-#define PRESTERA_FW_REG_OFFSET(f)	offsetof(struct prestera_fw_regs, f)
-
-#define PRESTERA_FW_READY_MAGIC	0xcafebabe
-
-/* fw registers */
-#define PRESTERA_FW_READY_REG		PRESTERA_FW_REG_OFFSET(fw_ready)
-
-#define PRESTERA_CMDQ_REG_OFFSET(q, f)			\
-	(PRESTERA_FW_REG_OFFSET(cmdq_list) +		\
-	 (q) * sizeof(struct prestera_fw_cmdq_regs) +	\
-	 offsetof(struct prestera_fw_cmdq_regs, f))
-
-#define PRESTERA_CMD_BUF_OFFS_REG	PRESTERA_FW_REG_OFFSET(cmd_offs)
-#define PRESTERA_CMD_BUF_LEN_REG	PRESTERA_FW_REG_OFFSET(cmd_len)
-#define PRESTERA_CMD_QNUM_REG		PRESTERA_FW_REG_OFFSET(cmd_qnum)
-#define PRESTERA_EVT_BUF_OFFS_REG	PRESTERA_FW_REG_OFFSET(evt_offs)
-#define PRESTERA_EVT_QNUM_REG		PRESTERA_FW_REG_OFFSET(evt_qnum)
-
-#define PRESTERA_CMDQ_REQ_CTL_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_req_ctl)
-#define PRESTERA_CMDQ_REQ_LEN_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_req_len)
-#define PRESTERA_CMDQ_RCV_CTL_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_rcv_ctl)
-#define PRESTERA_CMDQ_RCV_LEN_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, cmd_rcv_len)
-#define PRESTERA_CMDQ_OFFS_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, offs)
-#define PRESTERA_CMDQ_LEN_REG(q)	PRESTERA_CMDQ_REG_OFFSET(q, len)
-
-#define PRESTERA_FW_STATUS_REG		PRESTERA_FW_REG_OFFSET(fw_status)
-#define PRESTERA_RX_STATUS_REG		PRESTERA_FW_REG_OFFSET(rx_status)
-
-/* PRESTERA_CMDQ_REQ_CTL_REG flags */
-#define PRESTERA_CMD_F_REQ_SENT		BIT(0)
-#define PRESTERA_CMD_F_REPL_RCVD	BIT(1)
-
-/* PRESTERA_CMDQ_RCV_CTL_REG flags */
-#define PRESTERA_CMD_F_REPL_SENT	BIT(0)
-
-/* PRESTERA_FW_STATUS_REG flags */
-#define PRESTERA_STATUS_F_EVT_OFF	BIT(0)
-
-#define PRESTERA_EVTQ_REG_OFFSET(q, f)			\
-	(PRESTERA_FW_REG_OFFSET(evtq_list) +		\
-	 (q) * sizeof(struct prestera_fw_evtq_regs) +	\
-	 offsetof(struct prestera_fw_evtq_regs, f))
-
-#define PRESTERA_EVTQ_RD_IDX_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, rd_idx)
-#define PRESTERA_EVTQ_WR_IDX_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, wr_idx)
-#define PRESTERA_EVTQ_OFFS_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, offs)
-#define PRESTERA_EVTQ_LEN_REG(q)	PRESTERA_EVTQ_REG_OFFSET(q, len)
-
-#define prestera_fw_write(fw, reg, val)	writel(val, (fw)->hw_regs + (reg))
-#define prestera_fw_read(fw, reg)	readl((fw)->hw_regs + (reg))
-
-struct prestera_fw_evtq {
-	u8 __iomem *addr;
-	size_t len;
-};
-
-struct prestera_fw_cmdq {
-	/* serialize access to dev->send_req */
-	struct mutex cmd_mtx;
-	u8 __iomem *addr;
-	size_t len;
-};
-
-struct prestera_fw {
-	struct workqueue_struct *wq;
-	struct prestera_device dev;
-	struct pci_dev *pci_dev;
-	u8 __iomem *mem_addr;
-
-	u8 __iomem *ldr_regs;
-	u8 __iomem *hw_regs;
-
-	u8 __iomem *ldr_ring_buf;
-	u32 ldr_buf_len;
-	u32 ldr_wr_idx;
-
-	size_t cmd_mbox_len;
-	u8 __iomem *cmd_mbox;
-	struct prestera_fw_cmdq cmd_queue[PRESTERA_CMD_QNUM_MAX];
-	u8 cmd_qnum;
-	struct prestera_fw_evtq evt_queue[PRESTERA_EVT_QNUM_MAX];
-	u8 evt_qnum;
-	struct work_struct evt_work;
-	u8 __iomem *evt_buf;
-	u8 *evt_msg;
-};
-
-#define prestera_fw_dev(fw)	((fw)->dev.dev)
-
 #define PRESTERA_DEVICE(id) PCI_VDEVICE(MARVELL, (id))
 
 #define PRESTERA_DEV_ID_AC3X_98DX_55	0xC804
@@ -294,302 +134,6 @@ static struct prestera_pci_match {
 
 static int prestera_fw_load(struct prestera_fw *fw);
 
-static void prestera_fw_cmdq_lock(struct prestera_fw *fw, u8 qid)
-{
-	mutex_lock(&fw->cmd_queue[qid].cmd_mtx);
-}
-
-static void prestera_fw_cmdq_unlock(struct prestera_fw *fw, u8 qid)
-{
-	mutex_unlock(&fw->cmd_queue[qid].cmd_mtx);
-}
-
-static u32 prestera_fw_cmdq_len(struct prestera_fw *fw, u8 qid)
-{
-	return fw->cmd_queue[qid].len;
-}
-
-static u8 __iomem *prestera_fw_cmdq_buf(struct prestera_fw *fw, u8 qid)
-{
-	return fw->cmd_queue[qid].addr;
-}
-
-static u32 prestera_fw_evtq_len(struct prestera_fw *fw, u8 qid)
-{
-	return fw->evt_queue[qid].len;
-}
-
-static u32 prestera_fw_evtq_avail(struct prestera_fw *fw, u8 qid)
-{
-	u32 wr_idx = prestera_fw_read(fw, PRESTERA_EVTQ_WR_IDX_REG(qid));
-	u32 rd_idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
-
-	return CIRC_CNT(wr_idx, rd_idx, prestera_fw_evtq_len(fw, qid));
-}
-
-static void prestera_fw_evtq_rd_set(struct prestera_fw *fw, u8 qid, u32 idx)
-{
-	u32 rd_idx = idx & (prestera_fw_evtq_len(fw, qid) - 1);
-
-	prestera_fw_write(fw, PRESTERA_EVTQ_RD_IDX_REG(qid), rd_idx);
-}
-
-static u8 __iomem *prestera_fw_evtq_buf(struct prestera_fw *fw, u8 qid)
-{
-	return fw->evt_queue[qid].addr;
-}
-
-static u32 prestera_fw_evtq_read32(struct prestera_fw *fw, u8 qid)
-{
-	u32 rd_idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
-	u32 val;
-
-	val = readl(prestera_fw_evtq_buf(fw, qid) + rd_idx);
-	prestera_fw_evtq_rd_set(fw, qid, rd_idx + 4);
-	return val;
-}
-
-static ssize_t prestera_fw_evtq_read_buf(struct prestera_fw *fw, u8 qid,
-					 u8 *buf, size_t len)
-{
-	u32 idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
-	u8 __iomem *evtq_addr = prestera_fw_evtq_buf(fw, qid);
-	u32 *buf32 = (u32 *)buf;
-	int i;
-
-	for (i = 0; i < len / 4; buf32++, i++) {
-		*buf32 = readl_relaxed(evtq_addr + idx);
-		idx = (idx + 4) & (prestera_fw_evtq_len(fw, qid) - 1);
-	}
-
-	prestera_fw_evtq_rd_set(fw, qid, idx);
-
-	return i;
-}
-
-static u8 prestera_fw_evtq_pick(struct prestera_fw *fw)
-{
-	int qid;
-
-	for (qid = 0; qid < fw->evt_qnum; qid++) {
-		if (prestera_fw_evtq_avail(fw, qid) >= 4)
-			return qid;
-	}
-
-	return PRESTERA_EVT_QNUM_MAX;
-}
-
-static void prestera_fw_status_set(struct prestera_fw *fw, unsigned int val)
-{
-	u32 status = prestera_fw_read(fw, PRESTERA_FW_STATUS_REG);
-
-	status |= val;
-
-	prestera_fw_write(fw, PRESTERA_FW_STATUS_REG, status);
-}
-
-static void prestera_fw_status_clear(struct prestera_fw *fw, u32 val)
-{
-	u32 status = prestera_fw_read(fw, PRESTERA_FW_STATUS_REG);
-
-	status &= ~val;
-
-	prestera_fw_write(fw, PRESTERA_FW_STATUS_REG, status);
-}
-
-static void prestera_fw_evt_work_fn(struct work_struct *work)
-{
-	struct prestera_fw *fw;
-	u8 *msg;
-	u8 qid;
-
-	fw = container_of(work, struct prestera_fw, evt_work);
-	msg = fw->evt_msg;
-
-	prestera_fw_status_set(fw, PRESTERA_STATUS_F_EVT_OFF);
-
-	while ((qid = prestera_fw_evtq_pick(fw)) < PRESTERA_EVT_QNUM_MAX) {
-		u32 idx;
-		u32 len;
-
-		len = prestera_fw_evtq_read32(fw, qid);
-		idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));
-
-		WARN_ON(prestera_fw_evtq_avail(fw, qid) < len);
-
-		if (WARN_ON(len > PRESTERA_MSG_MAX_SIZE)) {
-			prestera_fw_evtq_rd_set(fw, qid, idx + len);
-			continue;
-		}
-
-		prestera_fw_evtq_read_buf(fw, qid, msg, len);
-
-		if (fw->dev.recv_msg)
-			fw->dev.recv_msg(&fw->dev, msg, len);
-	}
-
-	prestera_fw_status_clear(fw, PRESTERA_STATUS_F_EVT_OFF);
-}
-
-static int prestera_fw_wait_reg32(struct prestera_fw *fw, u32 reg, u32 val,
-				  unsigned int wait)
-{
-	if (prestera_wait(prestera_fw_read(fw, reg) == val || !fw->dev.running,
-			  wait))
-		return fw->dev.running ? 0 : -ENODEV;
-
-	return -EBUSY;
-}
-
-static void prestera_pci_copy_to(u8 __iomem *dst, u8 *src, size_t len)
-{
-	u32 __iomem *dst32 = (u32 __iomem *)dst;
-	u32 *src32 = (u32 *)src;
-	int i;
-
-	for (i = 0; i < (len / 4); dst32++, src32++, i++)
-		writel_relaxed(*src32, dst32);
-}
-
-static void prestera_pci_copy_from(u8 *dst, u8 __iomem *src, size_t len)
-{
-	u32 *dst32 = (u32 *)dst;
-	u32 __iomem *src32 = (u32 __iomem *)src;
-	int i;
-
-	for (i = 0; i < (len / 4); dst32++, src32++, i++)
-		*dst32 = readl_relaxed(src32);
-}
-
-static int prestera_fw_cmd_send(struct prestera_fw *fw, int qid,
-				u8 *in_msg, size_t in_size,
-				u8 *out_msg, size_t out_size,
-				unsigned int wait)
-{
-	u32 ret_size = 0;
-	int err = 0;
-
-	if (!wait)
-		wait = 30000;
-
-	if (ALIGN(in_size, 4) > prestera_fw_cmdq_len(fw, qid))
-		return -EMSGSIZE;
-
-	/* wait for finish previous reply from FW */
-	err = prestera_fw_wait_reg32(fw, PRESTERA_CMDQ_RCV_CTL_REG(qid),
-				     0, 1000);
-	if (err) {
-		dev_err(prestera_fw_dev(fw),
-			"finish reply from FW is timed out\n");
-		return err;
-	}
-
-	prestera_fw_write(fw, PRESTERA_CMDQ_REQ_LEN_REG(qid), in_size);
-	prestera_pci_copy_to(prestera_fw_cmdq_buf(fw, qid), in_msg, in_size);
-
-	prestera_fw_write(fw, PRESTERA_CMDQ_REQ_CTL_REG(qid),
-			  PRESTERA_CMD_F_REQ_SENT);
-
-	/* wait for reply from FW */
-	err = prestera_fw_wait_reg32(fw, PRESTERA_CMDQ_RCV_CTL_REG(qid),
-				     PRESTERA_CMD_F_REPL_SENT, wait);
-	if (err) {
-		dev_err(prestera_fw_dev(fw),
-			"reply from FW is timed out\n");
-		goto cmd_exit;
-	}
-
-	ret_size = prestera_fw_read(fw, PRESTERA_CMDQ_RCV_LEN_REG(qid));
-	if (ret_size > out_size) {
-		dev_err(prestera_fw_dev(fw), "ret_size (%u) > out_len(%zu)\n",
-			ret_size, out_size);
-		err = -EMSGSIZE;
-		goto cmd_exit;
-	}
-
-	prestera_pci_copy_from(out_msg, prestera_fw_cmdq_buf(fw, qid) + in_size,
-			       ret_size);
-
-cmd_exit:
-	prestera_fw_write(fw, PRESTERA_CMDQ_REQ_CTL_REG(qid),
-			  PRESTERA_CMD_F_REPL_RCVD);
-	return err;
-}
-
-static int prestera_fw_send_req(struct prestera_device *dev, int qid,
-				u8 *in_msg, size_t in_size, u8 *out_msg,
-				size_t out_size, unsigned int wait)
-{
-	struct prestera_fw *fw;
-	ssize_t ret;
-
-	fw = container_of(dev, struct prestera_fw, dev);
-
-	if (!fw->dev.running)
-		return -ENODEV;
-
-	prestera_fw_cmdq_lock(fw, qid);
-	ret = prestera_fw_cmd_send(fw, qid, in_msg, in_size, out_msg, out_size,
-				   wait);
-	prestera_fw_cmdq_unlock(fw, qid);
-
-	return ret;
-}
-
-static int prestera_fw_init(struct prestera_fw *fw)
-{
-	u8 __iomem *base;
-	int err;
-	u8 qid;
-
-	err = prestera_fw_load(fw);
-	if (err)
-		return err;
-
-	err = prestera_fw_wait_reg32(fw, PRESTERA_FW_READY_REG,
-				     PRESTERA_FW_READY_MAGIC, 20000);
-	if (err) {
-		dev_err(prestera_fw_dev(fw), "FW is failed to start\n");
-		return err;
-	}
-
-	base = fw->mem_addr;
-
-	fw->cmd_mbox = base + prestera_fw_read(fw, PRESTERA_CMD_BUF_OFFS_REG);
-	fw->cmd_mbox_len = prestera_fw_read(fw, PRESTERA_CMD_BUF_LEN_REG);
-	fw->cmd_qnum = prestera_fw_read(fw, PRESTERA_CMD_QNUM_REG);
-
-	for (qid = 0; qid < fw->cmd_qnum; qid++) {
-		u32 offs = prestera_fw_read(fw, PRESTERA_CMDQ_OFFS_REG(qid));
-		struct prestera_fw_cmdq *cmdq = &fw->cmd_queue[qid];
-
-		cmdq->len = prestera_fw_read(fw, PRESTERA_CMDQ_LEN_REG(qid));
-		cmdq->addr = fw->cmd_mbox + offs;
-		mutex_init(&cmdq->cmd_mtx);
-	}
-
-	fw->evt_buf = base + prestera_fw_read(fw, PRESTERA_EVT_BUF_OFFS_REG);
-	fw->evt_qnum = prestera_fw_read(fw, PRESTERA_EVT_QNUM_REG);
-	fw->evt_msg = kmalloc(PRESTERA_MSG_MAX_SIZE, GFP_KERNEL);
-	if (!fw->evt_msg)
-		return -ENOMEM;
-
-	for (qid = 0; qid < fw->evt_qnum; qid++) {
-		u32 offs = prestera_fw_read(fw, PRESTERA_EVTQ_OFFS_REG(qid));
-		struct prestera_fw_evtq *evtq = &fw->evt_queue[qid];
-
-		evtq->len = prestera_fw_read(fw, PRESTERA_EVTQ_LEN_REG(qid));
-		evtq->addr = fw->evt_buf + offs;
-	}
-
-	return 0;
-}
-
-static void prestera_fw_uninit(struct prestera_fw *fw)
-{
-	kfree(fw->evt_msg);
-}
-
 static irqreturn_t prestera_irq_handler(int irq, void *dev_id)
 {
 	struct prestera_fw *fw = dev_id;
@@ -601,7 +145,7 @@ static irqreturn_t prestera_irq_handler(int irq, void *dev_id)
 		}
 	}
 
-	queue_work(fw->wq, &fw->evt_work);
+	prestera_fw_queue_work(fw);
 
 	return IRQ_HANDLED;
 }
@@ -714,28 +258,6 @@ static bool prestera_ldr_is_ready(struct prestera_fw *fw)
 				 PRESTERA_LDR_READY_MAGIC;
 }
 
-static void prestera_fw_rev_parse(const struct prestera_fw_header *hdr,
-				  struct prestera_fw_rev *rev)
-{
-	u32 version = be32_to_cpu(hdr->version_value);
-
-	rev->maj = FW_VER_MAJ(version);
-	rev->min = FW_VER_MIN(version);
-	rev->sub = FW_VER_PATCH(version);
-}
-
-static int prestera_fw_rev_check(struct prestera_fw *fw)
-{
-	struct prestera_fw_rev *rev = &fw->dev.fw_rev;
-
-	if (rev->maj == PRESTERA_SUPP_FW_MAJ_VER &&
-	    rev->min == PRESTERA_SUPP_FW_MIN_VER) {
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
 static int prestera_fw_hdr_parse(struct prestera_fw *fw,
 				 const struct firmware *img)
 {
@@ -759,7 +281,7 @@ static int prestera_fw_hdr_parse(struct prestera_fw *fw,
 
 	if (prestera_fw_rev_check(fw)) {
 		dev_err(prestera_fw_dev(fw),
-			"Driver is incomatible with FW: version mismatch");
+			"Driver is incompatible with FW: version mismatch");
 		return -EINVAL;
 	}
 
@@ -922,17 +444,12 @@ static int prestera_pci_probe(struct pci_dev *pdev,
 	fw->dev.dev = &pdev->dev;
 	fw->dev.send_req = prestera_fw_send_req;
 	fw->dev.pp_regs = pp_addr;
+	fw->dev.dma_flags = GFP_DMA;
 	fw->dev.running = true;
 	fw->mem_addr = mem_addr;
 	fw->ldr_regs = mem_addr;
 	fw->hw_regs = mem_addr;
 
-	fw->wq = alloc_workqueue("prestera_fw_wq", WQ_HIGHPRI, 1);
-	if (!fw->wq)
-		goto err_wq_alloc;
-
-	INIT_WORK(&fw->evt_work, prestera_fw_evt_work_fn);
-
 	err = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);
 	if (err < 0) {
 		dev_err(&pdev->dev, "MSI IRQ init failed\n");
@@ -941,6 +458,11 @@ static int prestera_pci_probe(struct pci_dev *pdev,
 
 	pci_set_drvdata(pdev, fw);
 
+	err = prestera_fw_load(fw);
+
+	if (err)
+		goto err_fw_init;
+
 	err = prestera_fw_init(fw);
 	if (err)
 		goto err_fw_init;
@@ -967,9 +489,7 @@ static int prestera_pci_probe(struct pci_dev *pdev,
 err_fw_init:
 	pci_free_irq_vectors(pdev);
 err_irq_alloc:
-	destroy_workqueue(fw->wq);
-err_wq_alloc:
-	kfree(fw);
+
 err_pci_dev_alloc:
 err_pp_ioremap:
 err_mem_ioremap:
@@ -988,8 +508,6 @@ static void prestera_pci_remove(struct pci_dev *pdev)
 	free_irq(pci_irq_vector(pdev, 0), fw);
 	pci_free_irq_vectors(pdev);
 	prestera_device_unregister(&fw->dev);
-	flush_workqueue(fw->wq);
-	destroy_workqueue(fw->wq);
 	prestera_fw_uninit(fw);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_rxtx.c b/drivers/net/ethernet/marvell/prestera/prestera_rxtx.c
index 38aed5d..e91ec9a 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_rxtx.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_rxtx.c
@@ -109,6 +109,7 @@ struct mvsw_pr_rxtx_sdma {
 	spinlock_t tx_lock;
 	u32 map_addr;
 	u64 dma_mask;
+	gfp_t dma_flags;
 };
 
 struct prestera_rxtx {
@@ -128,7 +129,7 @@ static int mvsw_sdma_buf_desc_alloc(struct mvsw_pr_rxtx_sdma *sdma,
 	struct mvsw_sdma_desc *desc;
 	dma_addr_t dma;
 
-	desc = dma_pool_alloc(sdma->desc_pool, GFP_DMA | GFP_KERNEL, &dma);
+	desc = dma_pool_alloc(sdma->desc_pool, sdma->dma_flags | GFP_KERNEL, &dma);
 	if (!desc)
 		return -ENOMEM;
 
@@ -180,7 +181,7 @@ static int mvsw_sdma_rx_dma_alloc(struct mvsw_pr_rxtx_sdma *sdma,
 {
 	struct device *dev = sdma->sw->dev->dev;
 
-	buf->skb = alloc_skb(SDMA_BUFF_SIZE_MAX, GFP_DMA | GFP_ATOMIC);
+	buf->skb = alloc_skb(SDMA_BUFF_SIZE_MAX, sdma->dma_flags | GFP_ATOMIC);
 	if (!buf->skb)
 		return -ENOMEM;
 
@@ -530,7 +531,7 @@ static int mvsw_sdma_tx_buf_map(struct mvsw_pr_rxtx_sdma *sdma,
 	if (!dma_mapping_error(dma_dev, dma))
 		dma_unmap_single(dma_dev, dma, len, DMA_TO_DEVICE);
 
-	new_skb = alloc_skb(len, GFP_ATOMIC | GFP_DMA);
+	new_skb = alloc_skb(len, GFP_ATOMIC | sdma->dma_flags);
 	if (!new_skb)
 		goto err_alloc_skb;
 
@@ -715,6 +716,7 @@ int prestera_rxtx_switch_init(struct prestera_switch *sw)
 		goto err_hw_rxtx_init;
 	}
 
+	sdma->dma_flags = sw->dev->dma_flags;
 	sdma->dma_mask = dma_get_mask(sw->dev->dev);
 	sdma->sw = sw;
 
@@ -775,6 +777,7 @@ void prestera_rxtx_switch_fini(struct prestera_switch *sw)
 	mvsw_sdma_tx_fini(sdma);
 	dma_pool_destroy(sdma->desc_pool);
 	kfree(sw->rxtx);
+	sw->rxtx = NULL;
 	kfree(cpu_code_stats);
 }
 
@@ -867,6 +870,9 @@ netdev_tx_t prestera_rxtx_xmit(struct sk_buff *skb, struct prestera_port *port)
 	struct mvsw_pr_dsa dsa;
 	u64 skb_len = skb->len;
 
+	if (unlikely(!port->sw || !port->sw->rxtx))
+		goto tx_drop;
+
 	/* common DSA tag fill-up */
 	memset(&dsa, 0, sizeof(dsa));
 	dsa.dsa_cmd = MVSW_NET_DSA_CMD_FROM_CPU_E;
@@ -896,17 +902,17 @@ netdev_tx_t prestera_rxtx_xmit(struct sk_buff *skb, struct prestera_port *port)
 	/* } */
 
 	if (skb_cow_head(skb, dsa_resize_len) < 0)
-		goto tx_drop;
+		goto tx_drop_stats_inc;
 
 	/* expects skb->data at mac header */
 	skb_push(skb, dsa_resize_len);
 	memmove(skb->data, skb->data + dsa_resize_len, 2 * ETH_ALEN);
 
 	if (mvsw_pr_dsa_build(&dsa, skb->data + 2 * ETH_ALEN) != 0)
-		goto tx_drop;
+		goto tx_drop_stats_inc;
 
 	if (mvsw_pr_rxtx_sdma_xmit(port->sw->rxtx, skb))
-		goto tx_drop;
+		goto tx_drop_stats_inc;
 
 	rxtx_stats = this_cpu_ptr(port->rxtx_stats);
 	u64_stats_update_begin(&rxtx_stats->syncp);
@@ -916,9 +922,10 @@ netdev_tx_t prestera_rxtx_xmit(struct sk_buff *skb, struct prestera_port *port)
 
 	return NETDEV_TX_OK;
 
+tx_drop_stats_inc:
+	this_cpu_inc(port->rxtx_stats->tx_dropped);
 tx_drop:
 	dev_kfree_skb_any(skb);
-	this_cpu_inc(port->rxtx_stats->tx_dropped);
 	return NET_XMIT_DROP;
 }
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_shm.c b/drivers/net/ethernet/marvell/prestera/prestera_shm.c
new file mode 100644
index 0000000..20d959f
--- /dev/null
+++ b/drivers/net/ethernet/marvell/prestera/prestera_shm.c
@@ -0,0 +1,617 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
+/* Copyright (c) 2019-2021 Marvell International Ltd. All rights reserved */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/mmzone.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/kfifo.h>
+#include <linux/if_arp.h>
+#include <linux/mmu_context.h>
+
+#include "prestera.h"
+#include "prestera_fw.h"
+#include "prestera_shm.h"
+
+#define PRESTERA_SW_SHM_DEV_NAME "prestera_shm"
+#define PRESTERA_SHM_FIFO_SZ 128
+
+#define SIM_SDMA_RX_QUEUE_DESC_REG(n)	(0x260C + (n) * 16)
+#define SIM_SDMA_TX_QUEUE_DESC_REG	0x26C0
+#define SIM_REG(x) ((phys_addr_t *)((char *)shm_dev->fw.dev.pp_regs + (x)))
+#define SIM_REG_DEREF(x) (*(SIM_REG(x)))
+
+struct prestera_shm_msg {
+	int command;
+	long arg;
+};
+
+struct prestera_shm_dev {
+	struct device *dev_ptr;
+	atomic_t pending_intr_cntr;
+	wait_queue_head_t shm_queue;
+	struct task_struct *shm_kthread;
+	struct page *alloc_pages;
+	phys_addr_t addr_phys;
+	size_t size;
+	struct prestera_fw fw;
+	void __iomem *shm_mmap_memory;
+	dev_t shm_cdev_ids;
+	struct cdev shm_cdev;
+	struct class *shm_class;
+	struct task_struct *sim_kthread;
+	struct net_device *net_dev;
+	int initialized;
+};
+
+/*  Needed so devlink_nl_put_handle() won't crash trying to write NL attributes for bus name: */
+static struct bus_type prestera_shm_bus_type = {
+	.name		= "prestera_shm_bus",
+};
+
+/* Interface netdev name for simulation mode. When specified, enables simulation mode */
+static char *sim_devname;
+
+static netdev_tx_t prestera_shm_sim_netdev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int i = 0;
+	phys_addr_t pa;
+	unsigned int *ulptr;
+	unsigned char *dst_buf;
+	struct prestera_shm_dev **pp_dev;
+	struct prestera_shm_dev *shm_dev;
+
+	pp_dev = (struct prestera_shm_dev **)netdev_priv(dev);
+	shm_dev = *pp_dev;
+
+	pa = SIM_REG_DEREF(SIM_SDMA_RX_QUEUE_DESC_REG(0));
+	if (!pa) {
+		/*
+		 * We can either return NETDEV_TX_BUSY which will cause
+		 * constant requeueing and ksoftirqd running constantly
+		 * at 100% CPU (which causes appDemo initialization to fail)
+		 * or just free the SKB and return OK.
+		 */
+		dev_kfree_skb(skb);
+		dev->stats.tx_errors++;
+		return NETDEV_TX_OK;
+	}
+
+	ulptr = phys_to_virt(pa);
+
+	for (i = 0; ((i < 1000) && (ulptr[3])); i++) {
+		if (*ulptr & 0x80000000) {
+			/* found a ready buffer descriptor */
+			dst_buf = phys_to_virt(ulptr[2]);
+			skb_copy_bits(skb, 0, dst_buf, skb->len);
+			ulptr[1] = skb->len << 16;
+			*ulptr = 0x0C000000;
+			dev->stats.tx_packets++;
+			dev->stats.tx_bytes += skb->len;
+			dev_kfree_skb(skb);
+
+			return NETDEV_TX_OK;
+		}
+		pa = ulptr[3];
+		if (!pa)
+			break;
+		ulptr = phys_to_virt(pa);
+	}
+	dev->stats.tx_errors++;
+	return NETDEV_TX_BUSY;
+}
+
+static int prestera_shm_sim_set_mac_addr(struct net_device *dev, void *addr)
+{
+	eth_commit_mac_addr_change(dev, addr);
+	return 0;
+}
+
+static const struct net_device_ops shm_sim_netdev_ops = {
+	.ndo_start_xmit         = prestera_shm_sim_netdev_xmit,
+	.ndo_set_mac_address	= prestera_shm_sim_set_mac_addr,
+};
+
+static int prestera_shm_sim_sdma(void *data)
+{
+	int i = 0;
+	phys_addr_t pa;
+	unsigned int len;
+	unsigned int *ulptr;
+	unsigned char *dst_buf;
+	struct sk_buff *new_skb;
+	struct prestera_shm_dev *shm_dev = (struct prestera_shm_dev *)data;
+
+	while (!kthread_should_stop()) {
+		/* Simulate SDMA TX path */
+		pa = SIM_REG_DEREF(SIM_SDMA_TX_QUEUE_DESC_REG);
+		if (!pa) {
+			msleep(20);
+			continue;
+		}
+
+		ulptr = phys_to_virt(pa);
+
+		for (i = 0; ((i < 1000) && (ulptr[3])); i++) {
+			if (*ulptr & 0x80000000) {
+			/* found a ready to send buffer descriptor */
+				dst_buf = phys_to_virt(ulptr[2]);
+				len = ulptr[1] >> 16;
+				new_skb = alloc_skb(len, GFP_KERNEL);
+				skb_copy_to_linear_data(new_skb, dst_buf, len);
+				shm_dev->net_dev->stats.rx_packets++;
+				shm_dev->net_dev->stats.rx_bytes += len;
+
+				if (netif_receive_skb(new_skb) != NET_RX_SUCCESS)
+					dev_kfree_skb(new_skb);
+
+				*ulptr = 0x0300000;
+			}
+
+			pa = ulptr[3];
+			if (!pa)
+				break;
+
+			ulptr = phys_to_virt(pa);
+		}
+		msleep(20);
+	}
+
+	return 0;
+}
+
+/* mmap() handler -
+ * allocates kernel contiguous physical memory and map it to user-space
+ * for shared memory IPC interface to user-space
+ */
+
+static int prestera_shm_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct prestera_shm_dev *dev = filp->private_data;
+	void *vaddr;
+
+	dev->size = MAX_ORDER_NR_PAGES * PAGE_SIZE;
+
+	pr_err("%s: Entry. Size=%lu. VMA_size = %lu\n", __func__, dev->size,
+	       vma->vm_end - vma->vm_start);
+
+	dev->alloc_pages = alloc_pages(GFP_DMA, MAX_ORDER - 1);
+
+	if (!dev->alloc_pages/*dev->shm_mmap_memory*/) {
+		pr_err("%s: Failed allocating %lu bytes of memory.\n", __func__, dev->size);
+		return -ENOMEM;
+	}
+
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+
+	dev->addr_phys = (page_to_pfn(dev->alloc_pages) << PAGE_SHIFT);
+
+	vaddr = page_address(dev->alloc_pages);
+	dev->shm_mmap_memory = vaddr;
+	if (!dev->shm_mmap_memory) {
+		pr_err("%s: Failed remap kernel vaddr, %lu bytes.\n", __func__, dev->size);
+		return -ENOMEM;
+	}
+
+	/* In lieu of physical registers */
+	dev->fw.hw_regs = (u8 __iomem *)dev->shm_mmap_memory;
+	dev->fw.mem_addr = (u8 __iomem *)dev->shm_mmap_memory;
+	pr_info("%s: memptr %p hw_regs %p mem_addr %p\n", __func__,
+		dev->shm_mmap_memory, dev->fw.hw_regs,
+		dev->fw.mem_addr);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    dev->addr_phys >> PAGE_SHIFT,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot) < 0) {
+		pr_err("%s: failed remapping virt %lx phys %llx len %lu\n",
+		       __func__, vma->vm_start, dev->addr_phys,
+		       vma->vm_end - vma->vm_start);
+		__free_pages(dev->alloc_pages, MAX_ORDER_NR_PAGES);
+		return -EAGAIN;
+	}
+
+	pr_info("%s: remapped virt %lx phys %llx len %lu\n",
+		__func__, vma->vm_start, dev->addr_phys,
+		vma->vm_end - vma->vm_start);
+
+	return 0;
+}
+
+static int prestera_shm_open(struct inode *inode, struct file *filp)
+{
+	struct prestera_shm_dev *dev;
+
+	dev = container_of(inode->i_cdev, struct prestera_shm_dev, shm_cdev);
+
+	if (!dev->initialized)
+		return -ENODEV;
+
+	filp->private_data = dev;
+
+	return 0;
+}
+
+static int prestera_shm_release(struct inode *inode, struct file *filp)
+{
+	struct prestera_shm_dev *dev = filp->private_data;
+
+	__free_pages(dev->alloc_pages, MAX_ORDER - 1);
+	dev->alloc_pages = NULL;
+
+	dev->shm_mmap_memory = NULL;
+	filp->private_data = NULL;
+
+	return 0;
+}
+
+static void prestera_shm_handle_interrupt(struct prestera_shm_dev *dev)
+{
+	if (prestera_fw_read(&dev->fw, PRESTERA_RX_STATUS_REG)) {
+		prestera_fw_write(&dev->fw, PRESTERA_RX_STATUS_REG, 0);
+
+		if (likely(dev->fw.dev.recv_pkt))
+			dev->fw.dev.recv_pkt(&dev->fw.dev);
+	}
+}
+
+static int prestera_shm_kthread(void *data)
+{
+	struct prestera_shm_dev *dev = (struct prestera_shm_dev *)data;
+
+	sched_set_fifo(current);
+	while (!kthread_should_stop()) {
+		wait_event_interruptible(dev->shm_queue,
+					 ((kthread_should_stop()) ||
+					 (atomic_read(&dev->pending_intr_cntr) > 0)));
+
+		if (kthread_should_stop()) {
+			pr_err("%s: stopping...\n", __func__);
+			break;
+		}
+
+		while (atomic_fetch_dec(&dev->pending_intr_cntr))
+			prestera_fw_handle_event(&dev->fw);
+	}
+	return 0;
+}
+
+static int prestera_shm_ioctl_handle_one(struct prestera_shm_dev *dev,
+					 struct prestera_shm_msg *msg)
+{
+	int err;
+	struct prestera_fw_rev *rev = &dev->fw.dev.fw_rev;
+
+	switch (msg->command) {
+	case PRESTERA_SHM_INTERRUPT:
+		prestera_shm_handle_interrupt(dev);
+		atomic_inc(&dev->pending_intr_cntr);
+		wake_up(&dev->shm_queue);
+		return 0;
+
+	case PRESTERA_SHM_INIT:
+
+		if (!dev->shm_mmap_memory) {
+			dev_err(dev->dev_ptr, "%s: userspace must call mmap() for this driver before calling ioctl() with PRESTERA_SHM_INIT!",
+				__func__);
+			return -ENXIO;
+		}
+
+		err = prestera_fw_init(&dev->fw);
+		if (err)
+			return err;
+
+		prestera_fw_rev_parse_int(msg->arg, rev);
+		if (prestera_fw_rev_check(&dev->fw))
+			return -EINVAL;
+
+		pr_info("Before Registering prestera device\n");
+		err = prestera_device_register(&dev->fw.dev);
+		pr_info("Registered prestera device (return code %d).\n", err);
+		return err;
+	}
+
+	return -EINVAL;
+}
+
+/* Handle simulation of PCIe interrupt and firmware version number update
+ */
+static long prestera_shm_ioctl(struct file *filp, unsigned int command,
+			       unsigned long arg)
+{
+	struct prestera_shm_dev *dev = filp->private_data;
+	struct prestera_shm_msg msg;
+
+	msg.command = command;
+	msg.arg = arg;
+
+	return prestera_shm_ioctl_handle_one(dev, &msg);
+}
+
+static const struct file_operations shm_file_operations = {
+	.owner =	  THIS_MODULE,
+	.unlocked_ioctl = prestera_shm_ioctl,
+	.mmap =           prestera_shm_mmap,
+	.open =		  prestera_shm_open,
+	.release =	  prestera_shm_release,
+};
+
+/* Module device specific information initialization function -
+ * Allocates character device for ioctl() and mmap() functionalities
+ */
+
+static int prestera_shm_dev_init(struct prestera_shm_dev *dev,
+				 struct platform_device *pdev)
+{
+	int ret;
+	struct resource *resource = NULL;
+	void __iomem *base;
+	struct prestera_shm_dev **pp_dev;
+	unsigned char addr[ETH_ALEN];
+
+	atomic_set(&dev->pending_intr_cntr, 0);
+	init_waitqueue_head(&dev->shm_queue);
+	dev->shm_kthread = kthread_run(prestera_shm_kthread, (void *)dev,
+				       "prestera_shm_kthread");
+	if (!dev->shm_kthread)
+		return -ENOMEM;
+
+	ret = alloc_chrdev_region(&dev->shm_cdev_ids, 0, 1, PRESTERA_SHM_DEVNAME);
+	if (ret)
+		goto err_chrdev_region;
+
+	cdev_init(&dev->shm_cdev, &shm_file_operations);
+
+	ret = cdev_add(&dev->shm_cdev, dev->shm_cdev_ids, 1);
+	if (ret)
+		goto err_cdev_add;
+
+	dev->shm_class = class_create(THIS_MODULE, PRESTERA_SHM_DEVNAME);
+	if (IS_ERR(dev->shm_class)) {
+		ret = PTR_ERR(dev->shm_class);
+		goto err_class_create;
+	}
+
+	dev->dev_ptr = device_create(dev->shm_class, NULL, dev->shm_cdev_ids,
+				     NULL, PRESTERA_SHM_DEVNAME);
+
+	dev->dev_ptr->bus = &prestera_shm_bus_type;
+	if (IS_ERR(dev->dev_ptr)) {
+		ret = PTR_ERR(dev->dev_ptr);
+		goto err_dev_create;
+	}
+
+	if (!dev->dev_ptr->dma_mask) {
+		pr_info("%s: Fixing dma_mask...\n", __func__);
+		dev->dev_ptr->dma_mask = &dev->dev_ptr->coherent_dma_mask;
+	}
+
+	/*
+	 * AC5X DDR starts at physical address 0x2_0000_0000,
+	 * and can end at 0xff_ffff_ffff so we need a 40 bit
+	 * mask for it ...
+	 */
+	ret = dma_set_mask_and_coherent(dev->dev_ptr, DMA_BIT_MASK(40));
+	if (ret) {
+		dev_err(dev->dev_ptr, "fail to set DMA mask, return code is: %d\n", ret);
+		goto err_dma_mask;
+	}
+	dev->dev_ptr->bus_dma_limit = DMA_BIT_MASK(40);
+	pr_info("%s: coherent_dma_mask %llx bus_dma_limit %llx\n", __func__,
+		dev->dev_ptr->coherent_dma_mask, dev->dev_ptr->bus_dma_limit);
+#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
+	defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
+	defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
+	dev->dev_ptr->dma_coherent = true;
+#endif
+	if (!sim_devname) {
+		dev->fw.dev.dma_flags = GFP_DMA;
+		resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!resource || resource_size(resource) < PAGE_SIZE) {
+			dev_err(dev->dev_ptr, "Failed getting valid IO resource from device tree!\n");
+			goto err_dma_mask;
+		}
+
+		base = devm_ioremap_resource(dev->dev_ptr, resource);
+		if (IS_ERR(base))
+			goto err_dma_mask;
+
+	} else {
+		/* X86 does not really support GFP_DMA.
+		 *  It translates into ISA lower 16MB in memory.
+		 */
+		dev->fw.dev.dma_flags = 0;
+
+		/* Simulate MG SDMA area in software */
+		base = kzalloc(0x10000, GFP_KERNEL);
+		if (!base)
+			goto err_dma_mask;
+
+		dev->sim_kthread = kthread_run(prestera_shm_sim_sdma, dev, "sim_mg_sdma");
+
+		if (!dev->sim_kthread) {
+			kfree(base);
+			goto err_dma_mask;
+		}
+
+		dev->net_dev = alloc_etherdev(sizeof(void *));
+
+		if (!dev->net_dev) {
+			kthread_stop(dev->sim_kthread);
+			kfree(base);
+			goto err_dma_mask;
+		}
+
+		pp_dev = (struct prestera_shm_dev **)netdev_priv(dev->net_dev);
+		*pp_dev = dev;
+		dev->net_dev->netdev_ops = &shm_sim_netdev_ops;
+		SET_NETDEV_DEV(dev->net_dev, dev->dev_ptr);
+
+		dev->net_dev->mtu = 1536;
+		dev->net_dev->min_mtu = 64;
+		dev->net_dev->max_mtu = 1536;
+		dev->net_dev->type = ARPHRD_ETHER;
+		dev->net_dev->addr_len = ETH_ALEN;
+
+		strcpy(dev->net_dev->name, "sim%d");
+		get_random_bytes(addr + 1, ETH_ALEN - 1);
+		addr[0] = 0x0;
+		memcpy(dev->net_dev->dev_addr, addr, ETH_ALEN);
+
+		ret = register_netdev(dev->net_dev);
+
+		if (ret) {
+			pr_err("%s: failed registering network device %s with error number %d\n",
+			       __func__, dev->net_dev->name, ret);
+		} else {
+			netif_carrier_on(dev->net_dev);
+			pr_info("%s: ifindex %d ns %p netdev %p\n",
+				__func__, dev->net_dev->ifindex,
+				dev_net(dev->net_dev),
+				__dev_get_by_index(dev_net(dev->net_dev),
+						   dev->net_dev->ifindex));
+		}
+	}
+
+	dev->fw.dev.dev = dev->dev_ptr;
+	dev->fw.dev.send_req = prestera_fw_send_req;
+
+	dev->fw.dev.pp_regs = base;
+	if (resource)
+		pr_info("%s: remmap %llx..%llx to %p...\n",
+			__func__, resource->start, resource->end,
+			dev->fw.dev.pp_regs);
+	dev->fw.dev.running = true;
+
+	pr_info("prestera_shm: Initialized Marvell Prestera shared memory device\n");
+	dev->initialized = true;
+	return ret;
+
+err_dma_mask:
+	device_destroy(dev->shm_class, dev->shm_cdev_ids);
+err_dev_create:
+	class_destroy(dev->shm_class);
+err_class_create:
+	cdev_del(&dev->shm_cdev);
+err_cdev_add:
+	unregister_chrdev_region(dev->shm_cdev_ids, 1);
+err_chrdev_region:
+	kthread_stop(dev->shm_kthread);
+	return ret;
+}
+
+static int prestera_shm_probe(struct platform_device *pdev)
+{
+	struct prestera_shm_dev *dev;
+	int ret;
+
+	pr_info("prestera_shm: Probing Marvell Prestera shared memory driver...\n");
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	ret = prestera_shm_dev_init(dev, pdev);
+
+	if (ret < 0)
+		return ret;
+
+	platform_set_drvdata(pdev, dev);
+
+	pr_info("prestera_shm: Probed Marvell Prestera shared memory driver\n");
+	return 0;
+}
+
+static void prestera_shm_dev_deinit(struct prestera_shm_dev *dev)
+{
+	kthread_stop(dev->shm_kthread);
+	dev->fw.dev.running = false;
+	prestera_device_unregister(&dev->fw.dev);
+	prestera_fw_uninit(&dev->fw);
+	cancel_delayed_work_sync(&dev->fw.dev.keepalive_wdog_work);
+
+	if (sim_devname) {
+		kthread_stop(dev->sim_kthread);
+		unregister_netdev(dev->net_dev);
+	}
+	dev->dev_ptr->bus = NULL;
+	if (dev->alloc_pages)
+		__free_pages(dev->alloc_pages, MAX_ORDER - 1);
+
+	device_destroy(dev->shm_class, dev->shm_cdev_ids);
+	class_destroy(dev->shm_class);
+
+	cdev_del(&dev->shm_cdev);
+	unregister_chrdev_region(dev->shm_cdev_ids, 1);
+	if (sim_devname)
+		kfree(dev->fw.dev.pp_regs);
+	pr_info("%s: Unregistered Marvell Prestera shared memory driver\n", __func__);
+}
+
+static int prestera_shm_remove(struct platform_device *pdev)
+{
+	struct prestera_shm_dev *dev = platform_get_drvdata(pdev);
+
+	pr_info("%s: Unregistering Marvell Prestera shared memory driver.\n", __func__);
+	prestera_shm_dev_deinit(dev);
+	return 0;
+}
+
+static const struct of_device_id prestera_shm_of_match[] = {
+	{ .compatible = "marvell,prestera", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, prestera_shm_of_match);
+
+static struct platform_driver prestera_shm_driver = {
+	.driver		= {
+		.name	= PRESTERA_SW_SHM_DEV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = prestera_shm_of_match,
+	},
+	.probe		= prestera_shm_probe,
+	.remove		= prestera_shm_remove,
+};
+
+#ifdef CONFIG_X86_64
+struct platform_device *g_pdev;
+
+static int __init prestera_shm_init(void)
+{
+	int ret;
+
+	pr_info("Entry: %s\n", __func__);
+
+	g_pdev = platform_device_alloc("prestera_shm", -1);
+
+	if (!g_pdev)
+		return -ENOMEM;
+
+	return prestera_shm_probe(g_pdev);
+}
+
+/*
+ * Exit function of our module.
+ */
+static void __exit prestera_shm_exit(void)
+{
+	pr_info("Exit: %s\n", __func__);
+
+	prestera_shm_remove(g_pdev);
+	platform_device_unregister(g_pdev);
+}
+
+module_init(prestera_shm_init);
+module_exit(prestera_shm_exit);
+#else
+
+module_platform_driver(prestera_shm_driver);
+
+#endif
+
+MODULE_AUTHOR("Marvell Semi.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Marvell Prestera switch shared memory interface");
+module_param(sim_devname, charp, 0444);
+MODULE_PARM_DESC(sim_devname, "Interface name for simulation mode. When specified, enables simulation mode.");
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_shm.h b/drivers/net/ethernet/marvell/prestera/prestera_shm.h
new file mode 100644
index 0000000..a294995
--- /dev/null
+++ b/drivers/net/ethernet/marvell/prestera/prestera_shm.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
+/* Copyright (c) 2019-2021 Marvell International Ltd. All rights reserved */
+
+#ifndef PRESTERA_SHM_H_
+#define PRESTERA_SHM_H_
+
+#define PRESTERA_SHM_INTERRUPT_IOC_MAGIC	's'
+#define PRESTERA_SHM_INIT_IOC_MAGIC	'i'
+#define PRESTERA_SHM_BARRIER_IOC_MAGIC	'b'
+
+#define PRESTERA_SHM_INTERRUPT	_IOW(PRESTERA_SHM_INTERRUPT_IOC_MAGIC, 0, __u32)
+#define PRESTERA_SHM_INIT _IOW(PRESTERA_SHM_INIT_IOC_MAGIC, 0, __u32)
+#define PRESTERA_SHM_DEVNAME "prestera_shm"
+
+#endif
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_switchdev.c b/drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
index 5e635cd..7ac8bba 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
@@ -28,10 +28,26 @@ struct prestera_switchdev {
 	bool bridge_8021q_exists;
 };
 
+struct prestera_br_mdb_port {
+	struct prestera_bridge_port *br_port;
+	struct list_head br_mdb_port_node;
+};
+
+/* Software representation of MDB table. */
+struct prestera_br_mdb_entry {
+	struct prestera_bridge *bridge;
+	struct prestera_mdb_entry *mdb;
+	struct list_head br_mdb_port_list;
+	struct list_head br_mdb_entry_node;
+	bool enabled;
+};
+
 struct prestera_bridge {
 	struct net_device *dev;
 	struct list_head bridge_node;
 	struct list_head port_list;
+	struct list_head br_mdb_entry_list;
+	bool mrouter_exist;
 	u16 bridge_id;
 	/* This can be extended to list of isolation groups */
 	u32 isolation_srcid; /* source_id */
@@ -43,8 +59,10 @@ struct prestera_bridge_port {
 	struct prestera_bridge *bridge;
 	struct list_head bridge_node;
 	struct list_head vlan_list;
+	struct list_head br_mdb_port_list;
 	unsigned int ref_count;
 	u8 stp_state;
+	bool mrouter;
 	unsigned long flags;
 };
 
@@ -70,6 +88,30 @@ prestera_bridge_port_get(struct prestera_switch *sw,
 static void prestera_bridge_port_put(struct prestera_switch *sw,
 				     struct prestera_bridge_port *br_port);
 
+static int
+prestera_mdb_port_addr_obj_add(const struct switchdev_obj_port_mdb *mdb,
+			       struct switchdev_trans *trans);
+static int
+prestera_mdb_port_addr_obj_del(struct prestera_port *port,
+			       const struct switchdev_obj_port_mdb *mdb);
+
+static void
+prestera_mdb_flush_bridge_port(struct prestera_bridge_port *br_port);
+static int
+prestera_mdb_port_add(struct prestera_mdb_entry *br_mdb,
+		      struct net_device *orig_dev,
+		      const unsigned char addr[ETH_ALEN], u16 vid);
+
+static void
+prestera_br_mdb_entry_put(struct prestera_br_mdb_entry *br_mdb_entry);
+static int prestera_br_mdb_mc_enable_sync(struct prestera_bridge *br_dev);
+static int prestera_br_mdb_sync(struct prestera_bridge *br_dev);
+static int prestera_br_mdb_port_add(struct prestera_br_mdb_entry *br_mdb,
+				    struct prestera_bridge_port *br_port);
+static void
+prestera_mdb_port_del(struct prestera_mdb_entry *mdb,
+		      struct net_device *orig_dev);
+
 static struct prestera_bridge *
 prestera_bridge_find(const struct prestera_switch *sw,
 		     const struct net_device *br_dev)
@@ -145,7 +187,7 @@ static int prestera_br_port_flags_set(struct prestera_bridge_port *br_port,
 	if (err)
 		goto err_out;
 
-	err = prestera_port_mc_flood_set(port, br_port->flags & BR_MCAST_FLOOD);
+	err = prestera_br_mdb_mc_enable_sync(br_port->bridge);
 	if (err)
 		goto err_out;
 
@@ -347,6 +389,8 @@ prestera_port_vlan_bridge_leave(struct prestera_port_vlan *port_vlan)
 	else
 		prestera_fdb_flush_port_vlan(port, vid, mode);
 
+	prestera_mdb_flush_bridge_port(br_port);
+
 	list_del(&port_vlan->bridge_vlan_node);
 	prestera_bridge_vlan_put(br_vlan);
 	prestera_port_vid_stp_set(port, vid, BR_STATE_FORWARDING);
@@ -452,15 +496,22 @@ static int prestera_port_obj_add(struct net_device *dev,
 				 struct switchdev_trans *trans,
 				 struct netlink_ext_ack *extack)
 {
-	int err = 0;
 	struct prestera_port *port = netdev_priv(dev);
 	const struct switchdev_obj_port_vlan *vlan;
+	const struct switchdev_obj_port_mdb *mdb;
+	int err = 0;
 
 	switch (obj->id) {
 	case SWITCHDEV_OBJ_ID_PORT_VLAN:
 		vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);
 		err = prestera_port_vlans_add(port, vlan, trans, extack);
 		break;
+	case SWITCHDEV_OBJ_ID_PORT_MDB:
+		mdb = SWITCHDEV_OBJ_PORT_MDB(obj);
+		err = prestera_mdb_port_addr_obj_add(mdb, trans);
+		break;
+	case SWITCHDEV_OBJ_ID_HOST_MDB:
+		fallthrough;
 	default:
 		err = -EOPNOTSUPP;
 	}
@@ -511,14 +562,19 @@ static int prestera_port_vlans_del(struct prestera_port *port,
 static int prestera_port_obj_del(struct net_device *dev,
 				 const struct switchdev_obj *obj)
 {
-	int err = 0;
 	struct prestera_port *port = netdev_priv(dev);
+	const struct switchdev_obj_port_mdb *mdb;
+	int err = 0;
 
 	switch (obj->id) {
 	case SWITCHDEV_OBJ_ID_PORT_VLAN:
 		err = prestera_port_vlans_del(port,
 					      SWITCHDEV_OBJ_PORT_VLAN(obj));
 		break;
+	case SWITCHDEV_OBJ_ID_PORT_MDB:
+		mdb = SWITCHDEV_OBJ_PORT_MDB(obj);
+		err = prestera_mdb_port_addr_obj_del(port, mdb);
+		break;
 	default:
 		err = -EOPNOTSUPP;
 		break;
@@ -664,6 +720,208 @@ static int prestera_port_attr_stp_state_set(struct prestera_port *port,
 	return err;
 }
 
+static int
+prestera_br_port_lag_mdb_mc_enable_sync(struct prestera_bridge_port *br_port,
+					bool enabled)
+{
+	struct prestera_port *pr_port;
+	struct prestera_switch *sw;
+	u16 lag_id;
+	int err;
+
+	pr_port = prestera_port_dev_lower_find(br_port->dev);
+	if (!pr_port)
+		return 0;
+
+	sw = pr_port->sw;
+	err = prestera_lag_id_find(sw, br_port->dev, &lag_id);
+	if (err)
+		return err;
+
+	list_for_each_entry(pr_port, &sw->port_list, list) {
+		if (pr_port->lag_id == lag_id) {
+			err = prestera_port_mc_flood_set(pr_port, enabled);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int prestera_br_mdb_mc_enable_sync(struct prestera_bridge *br_dev)
+{
+	struct prestera_bridge_port *br_port;
+	struct prestera_port *port;
+	bool enabled;
+	int err;
+
+	/*
+	 * if mrouter exists:
+	 *  - make sure every mrouter receives unreg mcast traffic;
+	 * if mrouter doesn't exists:
+	 *  - make sure every port receives unreg mcast traffic;
+	 */
+	list_for_each_entry(br_port, &br_dev->port_list,
+			    bridge_node) {
+		if (br_dev->multicast_enabled && br_dev->mrouter_exist)
+			enabled = br_port->mrouter;
+		else
+			enabled = br_port->flags & BR_MCAST_FLOOD;
+
+		if (netif_is_lag_master(br_port->dev)) {
+			err = prestera_br_port_lag_mdb_mc_enable_sync(br_port,
+								      enabled);
+			if (err)
+				return err;
+			continue;
+		}
+
+		port = prestera_port_dev_lower_find(br_port->dev);
+		if (!port)
+			continue;
+
+		err = prestera_port_mc_flood_set(port, enabled);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static bool
+prestera_br_mdb_port_is_member(struct prestera_br_mdb_entry *br_mdb,
+			       struct net_device *orig_dev)
+{
+	struct prestera_br_mdb_port *tmp_port;
+
+	list_for_each_entry(tmp_port, &br_mdb->br_mdb_port_list,
+			    br_mdb_port_node)
+		if (tmp_port->br_port->dev == orig_dev)
+			return true;
+
+	return false;
+}
+
+/* Sync bridge mdb (software table) with HW table (if MC is enabled). */
+static int prestera_br_mdb_sync(struct prestera_bridge *br_dev)
+{
+	struct prestera_br_mdb_port *br_mdb_port;
+	struct prestera_bridge_port *br_port;
+	struct prestera_br_mdb_entry *br_mdb;
+	struct prestera_mdb_entry *mdb;
+	struct prestera_port *pr_port;
+	int err = 0;
+
+	if (!br_dev->multicast_enabled)
+		return 0;
+
+	list_for_each_entry(br_mdb, &br_dev->br_mdb_entry_list,
+			    br_mdb_entry_node) {
+		mdb = br_mdb->mdb;
+		/*
+		 * Make sure every port that explicitly been added to the mdb
+		 * joins the specified group.
+		 */
+		list_for_each_entry(br_mdb_port, &br_mdb->br_mdb_port_list,
+				    br_mdb_port_node) {
+			br_port = br_mdb_port->br_port;
+			pr_port = prestera_port_dev_lower_find(br_port->dev);
+
+			/*
+			 * Match only mdb and br_mdb ports that belong to the
+			 * same broadcast domain.
+			 */
+			if (br_dev->vlan_enabled &&
+			    !prestera_port_vlan_find_by_vid(pr_port,
+							    mdb->vid))
+				continue;
+
+			/*
+			 * If port is not in MDB or there's no Mrouter
+			 * clear HW mdb.
+			 */
+			if (prestera_br_mdb_port_is_member(br_mdb,
+							   br_mdb_port->br_port->dev) &&
+							   br_dev->mrouter_exist)
+				err = prestera_mdb_port_add(mdb, br_port->dev,
+							    mdb->addr,
+							    mdb->vid);
+			else
+				prestera_mdb_port_del(mdb, br_port->dev);
+
+			if (err)
+				return err;
+		}
+
+		/*
+		 * Make sure that every mrouter port joins every MC group int
+		 * broadcast domain. If it's not an mrouter - it should leave
+		 */
+		list_for_each_entry(br_port, &br_dev->port_list, bridge_node) {
+			pr_port = prestera_port_dev_lower_find(br_port->dev);
+
+			/*
+			 * Make sure mrouter woudln't receive traffci from
+			 * another broadcast domain (e.g. from a vlan, which
+			 * mrouter port is not a member of).
+			 */
+			if (br_dev->vlan_enabled &&
+			    !prestera_port_vlan_find_by_vid(pr_port,
+							    mdb->vid))
+				continue;
+
+			if (br_port->mrouter) {
+				err = prestera_mdb_port_add(mdb, br_port->dev,
+							    mdb->addr,
+							    mdb->vid);
+				if (err)
+					return err;
+			} else if (!br_port->mrouter &&
+				   !prestera_br_mdb_port_is_member
+				   (br_mdb, br_port->dev)) {
+				prestera_mdb_port_del(mdb, br_port->dev);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int
+prestera_mdb_enable_set(struct prestera_br_mdb_entry *br_mdb, bool enable)
+{
+	int err;
+
+	if (enable != br_mdb->enabled) {
+		if (enable)
+			err = prestera_hw_mdb_create(br_mdb->mdb);
+		else
+			err = prestera_hw_mdb_destroy(br_mdb->mdb);
+
+		if (err)
+			return err;
+
+		br_mdb->enabled = enable;
+	}
+
+	return 0;
+}
+
+static int
+prestera_br_mdb_enable_set(struct prestera_bridge *br_dev, bool enable)
+{
+	struct prestera_br_mdb_entry *br_mdb;
+	int err;
+
+	list_for_each_entry(br_mdb, &br_dev->br_mdb_entry_list,
+			    br_mdb_entry_node)
+		if (prestera_mdb_enable_set(br_mdb, enable))
+			return err;
+
+	return 0;
+}
+
 static int prestera_port_attr_br_mc_disabled_set(struct prestera_port *port,
 						 struct switchdev_trans *trans,
 						 struct net_device *orig_dev,
@@ -671,9 +929,6 @@ static int prestera_port_attr_br_mc_disabled_set(struct prestera_port *port,
 {
 	struct prestera_switch *sw = port->sw;
 	struct prestera_bridge *br_dev;
-	struct prestera_bridge_port *br_port;
-	bool enabled = !mc_disabled;
-	int err;
 
 	if (!switchdev_trans_ph_prepare(trans))
 		return 0;
@@ -682,17 +937,60 @@ static int prestera_port_attr_br_mc_disabled_set(struct prestera_port *port,
 	if (!br_dev)
 		return 0;
 
-	if (br_dev->multicast_enabled == enabled)
+	br_dev->multicast_enabled = !mc_disabled;
+
+	/* There's no point in enabling mdb back if router is missing. */
+	WARN_ON(prestera_br_mdb_enable_set(br_dev, br_dev->multicast_enabled &&
+					   br_dev->mrouter_exist));
+
+	WARN_ON(prestera_br_mdb_sync(br_dev));
+
+	WARN_ON(prestera_br_mdb_mc_enable_sync(br_dev));
+
+	return 0;
+}
+
+static bool
+prestera_bridge_mdb_mc_mrouter_exists(struct prestera_bridge *br_dev)
+{
+	struct prestera_bridge_port *br_port;
+
+	list_for_each_entry(br_port, &br_dev->port_list, bridge_node)
+		if (br_port->mrouter)
+			return true;
+
+	return false;
+}
+
+static int
+prestera_port_attr_mrouter_set(struct prestera_port *port,
+			       struct net_device *orig_dev,
+			       bool is_port_mrouter)
+{
+	struct prestera_bridge_port *br_port;
+	struct prestera_bridge *br_dev;
+
+	br_port = prestera_bridge_port_find(port->sw, orig_dev);
+	if (!br_port)
 		return 0;
 
-	list_for_each_entry(br_port, &br_dev->port_list, bridge_node) {
-		err = prestera_port_mc_flood_set(netdev_priv(br_port->dev),
-						 enabled);
-		if (err)
-			return err;
-	}
+	br_dev = br_port->bridge;
+	br_port->mrouter = is_port_mrouter;
 
-	br_dev->multicast_enabled = enabled;
+	br_dev->mrouter_exist = prestera_bridge_mdb_mc_mrouter_exists(br_dev);
+
+	/*
+	 * Enable MDB processing if both mrouter exists and mc is enabled.
+	 * In case if MC enabled, but there is no mrouter, device would flood
+	 * all multicast traffic (even if MDB table is not empty) with the use
+	 * of bridge's flood capabilities (without the use of flood_domain).
+	 */
+	WARN_ON(prestera_br_mdb_enable_set(br_dev, br_dev->multicast_enabled &&
+					   br_dev->mrouter_exist));
+
+	WARN_ON(prestera_br_mdb_sync(br_dev));
+
+	WARN_ON(prestera_br_mdb_mc_enable_sync(br_dev));
 
 	return 0;
 }
@@ -729,6 +1027,10 @@ static int prestera_port_obj_attr_set(struct net_device *dev,
 						     attr->orig_dev,
 						     attr->u.vlan_filtering);
 		break;
+	case SWITCHDEV_ATTR_ID_PORT_MROUTER:
+		err = prestera_port_attr_mrouter_set(port, attr->orig_dev,
+						     attr->u.mrouter);
+		break;
 	case SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:
 		err = prestera_port_attr_br_mc_disabled_set(port, trans,
 							    attr->orig_dev,
@@ -994,6 +1296,7 @@ prestera_bridge_create(struct prestera_switch *sw, struct net_device *br_dev)
 	bridge->multicast_enabled = br_multicast_enabled(br_dev);
 	bridge->mrouter = br_multicast_router(br_dev);
 	INIT_LIST_HEAD(&bridge->port_list);
+	INIT_LIST_HEAD(&bridge->br_mdb_entry_list);
 
 	list_add(&bridge->bridge_node, &sw->swdev->bridge_list);
 
@@ -1010,6 +1313,7 @@ prestera_bridge_destroy(struct prestera_switch *sw,
 	else
 		prestera_hw_bridge_delete(sw, bridge->bridge_id);
 
+	WARN_ON(!list_empty(&bridge->br_mdb_entry_list));
 	WARN_ON(!list_empty(&bridge->port_list));
 	kfree(bridge);
 }
@@ -1052,6 +1356,8 @@ prestera_bridge_port_create(struct prestera_bridge *bridge,
 	br_port->flags = BR_LEARNING | BR_FLOOD | BR_LEARNING_SYNC |
 				BR_MCAST_FLOOD;
 	INIT_LIST_HEAD(&br_port->vlan_list);
+	INIT_LIST_HEAD(&br_port->br_mdb_port_list);
+
 	list_add(&br_port->bridge_node, &bridge->port_list);
 	br_port->ref_count = 1;
 
@@ -1063,6 +1369,7 @@ prestera_bridge_port_destroy(struct prestera_bridge_port *br_port)
 {
 	list_del(&br_port->bridge_node);
 	WARN_ON(!list_empty(&br_port->vlan_list));
+	WARN_ON(!list_empty(&br_port->br_mdb_port_list));
 	kfree(br_port);
 }
 
@@ -1236,6 +1543,8 @@ void prestera_port_bridge_leave(struct prestera_port *port,
 	else
 		prestera_bridge_8021d_port_leave(bridge, br_port, port);
 
+	prestera_mdb_flush_bridge_port(br_port);
+
 	prestera_br_port_flags_reset(br_port, port);
 	prestera_port_vid_stp_set(port, PRESTERA_VID_ALL, BR_STATE_FORWARDING);
 	prestera_bridge_port_put(sw, br_port);
@@ -1257,6 +1566,270 @@ static int prestera_fdb_init(struct prestera_switch *sw)
 	return 0;
 }
 
+static struct prestera_br_mdb_entry *
+prestera_br_mdb_entry_create(struct prestera_switch *sw,
+			     struct prestera_bridge *br_dev,
+			     const unsigned char *addr, u16 vid)
+{
+	struct prestera_br_mdb_entry *br_mdb_entry;
+	struct prestera_mdb_entry *mdb_entry;
+
+	br_mdb_entry = kzalloc(sizeof(*br_mdb_entry), GFP_KERNEL);
+	if (!br_mdb_entry)
+		return NULL;
+
+	mdb_entry = prestera_mdb_entry_create(sw, addr, vid);
+	if (!mdb_entry)
+		goto err_mdb_alloc;
+
+	br_mdb_entry->mdb = mdb_entry;
+	br_mdb_entry->bridge = br_dev;
+	br_mdb_entry->enabled = true;
+	INIT_LIST_HEAD(&br_mdb_entry->br_mdb_port_list);
+
+	list_add(&br_mdb_entry->br_mdb_entry_node, &br_dev->br_mdb_entry_list);
+
+	return br_mdb_entry;
+
+err_mdb_alloc:
+	kfree(br_mdb_entry);
+	return NULL;
+}
+
+static struct prestera_br_mdb_entry *
+prestera_br_mdb_entry_find(struct prestera_bridge *br_dev,
+			   const unsigned char *addr, u16 vid)
+{
+	struct prestera_br_mdb_entry *br_mdb;
+
+	list_for_each_entry(br_mdb, &br_dev->br_mdb_entry_list,
+			    br_mdb_entry_node)
+		if (ether_addr_equal(&br_mdb->mdb->addr[0], addr) &&
+		    vid == br_mdb->mdb->vid)
+			return br_mdb;
+
+	return NULL;
+}
+
+static struct prestera_br_mdb_entry *
+prestera_br_mdb_entry_get(struct prestera_switch *sw,
+			  struct prestera_bridge *br_dev,
+			  const unsigned char *addr, u16 vid)
+{
+	struct prestera_br_mdb_entry *br_mdb;
+
+	br_mdb = prestera_br_mdb_entry_find(br_dev, addr, vid);
+	if (br_mdb)
+		return br_mdb;
+
+	return prestera_br_mdb_entry_create(sw, br_dev, addr, vid);
+}
+
+static void
+prestera_br_mdb_entry_put(struct prestera_br_mdb_entry *br_mdb)
+{
+	struct prestera_bridge_port *br_port;
+
+	if (list_empty(&br_mdb->br_mdb_port_list)) {
+		list_for_each_entry(br_port, &br_mdb->bridge->port_list,
+				    bridge_node)
+			prestera_mdb_port_del(br_mdb->mdb, br_port->dev);
+
+		prestera_mdb_entry_destroy(br_mdb->mdb);
+		list_del(&br_mdb->br_mdb_entry_node);
+		kfree(br_mdb);
+	}
+}
+
+static int prestera_br_mdb_port_add(struct prestera_br_mdb_entry *br_mdb,
+				    struct prestera_bridge_port *br_port)
+{
+	struct prestera_br_mdb_port *br_mdb_port;
+
+	br_mdb_port = kzalloc(sizeof(*br_mdb_port), GFP_KERNEL);
+	if (!br_mdb_port)
+		return -ENOMEM;
+
+	br_mdb_port->br_port = br_port;
+	list_add(&br_mdb_port->br_mdb_port_node,
+		 &br_mdb->br_mdb_port_list);
+
+	return 0;
+}
+
+static void
+prestera_br_mdb_port_del(struct prestera_br_mdb_entry *br_mdb,
+			 struct prestera_bridge_port *br_port)
+{
+	struct prestera_br_mdb_port *br_mdb_port, *tmp;
+
+	list_for_each_entry_safe(br_mdb_port, tmp, &br_mdb->br_mdb_port_list,
+				 br_mdb_port_node) {
+		if (br_mdb_port->br_port == br_port) {
+			list_del(&br_mdb_port->br_mdb_port_node);
+			kfree(br_mdb_port);
+		}
+	}
+}
+
+static int
+prestera_mdb_port_add(struct prestera_mdb_entry *mdb,
+		      struct net_device *orig_dev,
+		      const unsigned char addr[ETH_ALEN], u16 vid)
+{
+	struct prestera_flood_domain *flood_domain = mdb->flood_domain;
+	int err;
+
+	if (!prestera_flood_domain_port_find(flood_domain,
+					     orig_dev, vid)) {
+		err = prestera_flood_domain_port_create(flood_domain, orig_dev,
+							vid);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static void
+prestera_mdb_port_del(struct prestera_mdb_entry *mdb,
+		      struct net_device *orig_dev)
+{
+	struct prestera_flood_domain *fl_domain = mdb->flood_domain;
+	struct prestera_flood_domain_port *flood_domain_port;
+
+	flood_domain_port = prestera_flood_domain_port_find(fl_domain,
+							    orig_dev,
+							    mdb->vid);
+	if (flood_domain_port)
+		prestera_flood_domain_port_destroy(flood_domain_port);
+}
+
+static void
+prestera_mdb_flush_bridge_port(struct prestera_bridge_port *br_port)
+{
+	struct prestera_br_mdb_port *br_mdb_port, *tmp_port;
+	struct prestera_br_mdb_entry *br_mdb, *br_mdb_tmp;
+	struct prestera_bridge *br_dev = br_port->bridge;
+	struct prestera_mdb_entry *mdb;
+
+	list_for_each_entry_safe(br_mdb, br_mdb_tmp, &br_dev->br_mdb_entry_list,
+				 br_mdb_entry_node) {
+		mdb = br_mdb->mdb;
+
+		list_for_each_entry_safe(br_mdb_port, tmp_port,
+					 &br_mdb->br_mdb_port_list,
+					 br_mdb_port_node) {
+			prestera_mdb_port_del(br_mdb->mdb,
+					      br_mdb_port->br_port->dev);
+			prestera_br_mdb_port_del(br_mdb,  br_mdb_port->br_port);
+			prestera_br_mdb_entry_put(br_mdb);
+		}
+	}
+}
+
+static int
+prestera_mdb_port_addr_obj_add(const struct switchdev_obj_port_mdb *mdb,
+			       struct switchdev_trans *trans)
+{
+	struct prestera_br_mdb_entry *br_mdb;
+	struct prestera_bridge_port *br_port;
+	struct prestera_bridge *br_dev;
+	struct prestera_switch *sw;
+	struct prestera_port *port;
+	int err;
+
+	if (switchdev_trans_ph_commit(trans))
+		return 0;
+
+	sw = prestera_switch_get(mdb->obj.orig_dev);
+	port = prestera_port_dev_lower_find(mdb->obj.orig_dev);
+
+	br_port = prestera_bridge_port_find(sw, mdb->obj.orig_dev);
+	if (!br_port)
+		return 0;
+
+	br_dev = br_port->bridge;
+
+	if (mdb->vid && !prestera_port_vlan_find_by_vid(port, mdb->vid))
+		return 0;
+
+	if (mdb->vid)
+		br_mdb = prestera_br_mdb_entry_get(sw, br_dev, &mdb->addr[0],
+						   mdb->vid);
+	else
+		br_mdb = prestera_br_mdb_entry_get(sw, br_dev, &mdb->addr[0],
+						   br_dev->bridge_id);
+
+	if (!br_mdb)
+		return -ENOMEM;
+
+	/*
+	 * Make sure newly allocated MDB entry gets disabled if either MC is
+	 * disabled, or the mrouter does not exist.
+	 */
+	WARN_ON(prestera_mdb_enable_set(br_mdb, br_dev->multicast_enabled &&
+					br_dev->mrouter_exist));
+
+	err = prestera_br_mdb_port_add(br_mdb, br_port);
+	if (err) {
+		prestera_br_mdb_entry_put(br_mdb);
+		return err;
+	}
+
+	err = prestera_br_mdb_sync(br_dev);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int
+prestera_mdb_port_addr_obj_del(struct prestera_port *port,
+			       const struct switchdev_obj_port_mdb *mdb)
+{
+	struct prestera_br_mdb_entry *br_mdb;
+	struct prestera_bridge_port *br_port;
+	struct prestera_bridge *br_dev;
+	int err;
+
+	/* Bridge port no longer exists - and so does this MDB entry */
+	br_port = prestera_bridge_port_find(port->sw, mdb->obj.orig_dev);
+	if (!br_port)
+		return 0;
+
+	/* Removing MDB with non-existing VLAN - not supported; */
+	if (mdb->vid && !prestera_port_vlan_find_by_vid(port, mdb->vid))
+		return 0;
+
+	br_dev = br_port->bridge;
+
+	if (br_port->bridge->vlan_enabled)
+		br_mdb = prestera_br_mdb_entry_find(br_dev, &mdb->addr[0],
+						    mdb->vid);
+	else
+		br_mdb = prestera_br_mdb_entry_find(br_dev, &mdb->addr[0],
+						    br_port->bridge->bridge_id);
+
+	if (!br_mdb)
+		return 0;
+
+	/*
+	 * Since there might be a situation that this port was the last in the
+	 * MDB group, we have to both remove this port from software and HW MDB,
+	 * and then sync MDB table, and destroy software MDB (if needed).
+	 */
+	prestera_br_mdb_port_del(br_mdb, br_port);
+
+	prestera_br_mdb_entry_put(br_mdb);
+
+	err = prestera_br_mdb_sync(br_dev);
+	if (err)
+		return err;
+
+	return 0;
+}
+
 int prestera_switchdev_init(struct prestera_switch *sw)
 {
 	struct prestera_switchdev *swdev;
